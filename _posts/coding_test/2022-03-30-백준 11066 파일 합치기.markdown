---
layout: post
title: "백준: 11066 파일 합치기"
excerpt: "Python, DP"
date: 2022-03-30 23:09:00 +0900
categories:
  - Baekjoon
tags:
  - DP
---

- [문제](#문제)
- [입력](#입력)
- [출력](#출력)
- [예제 입력](#예제-입력)
- [예제 출력](#예제-출력)
- [문제 풀이](#문제-풀이)
  - [코드 분석](#코드-분석)
    - [전체 코드](#전체-코드)
    - [준비](#준비)
    - [풀이](#풀이)
- [총평](#총평)

# 문제

소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.

예를 들어, C1, C2, C3, C4가 연속적인 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.

소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.

# 입력

프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 500)가 주어진다. 두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. 파일의 크기는 10,000을 초과하지 않는다.

# 출력

프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행에 출력하는데, 모든 장을 합치는데 필요한 최소비용을 출력한다.

# 예제 입력

```
2
4
40 30 30 50
15
1 21 3 4 5 35 5 4 3 5 98 21 14 17 32
```

# 예제 출력

```
300
864
```

# 문제 풀이

파일을 합치는 경우는 매우 다양하다.

`novel = [40, 30, 30, 50]`

우리가 최종적으로 구해야 할 것은 처음부터 끝까지 다 더하는 경우이다. 즉, dp에서 처음부터 끝까지를 표현할 수 있어야 하는데 그렇게 하기 위해서 dp를 2차원 테이블로 만들어서 구현해준다. 예를 들어 dp[i][j] (i > j)라고 한다면, i부터 j까지 더하는 경우를 의미한다.

파일은 최소 두 개 이상을 더해야 하므로 두 개부터 더하는 경우부터 시작해서 세 개, ... , 처음부터 끝까지 다 더하는 경우를 구한다. 이때, 최소 경우를 구하기 때문에 min 함수를 사용한다.

* 길이가 2일 때

```
dp[1][2] = novel[1] + novel[2] (= sum(novel[1:1 + 2]))
dp[2][3] = novel[2] + novel[3] (= sum(novel[2:2 + 2]))
dp[3][4] = novel[3] + novel[4] (= sum(novel[3:3 + 2]))
```

* 길이가 3일 때

길이가 3일 때는 다르게 생각해야 한다. 왜냐하면 a, b, c를 더한다고 할 때, ((a + b) + c) + (a + b + c) 혹은 (a + (b + c)) + (a + b + c)로 구해줘야 하기 때문이다.

```
dp[1][3] = min(dp[1][1] + dp[2][3], dp[1][2] + dp[3]) + sum(novel[1:1 + 3])
dp[2][4] = min(dp[2][2] + dp[3][4], dp[2][3] + dp[4][4]) + sum(novel[2:2 + 3])
```

* 길이가 4일 때

```
dp[1][4] = min(dp[1][1] + dp[2][4], dp[1][2] + dp[3][4], dp[1][3] + dp[4][4]) + sum(novel[1:1 + 4])
```

min 함수를 자세히 보면 이미 다 구했었던 값들이다. dp에 이미 저장된 값들을 토대로 최소 비용을 구할 수 있게 된다.

## 코드 분석

### 전체 코드

```py
import sys
input = sys.stdin.readline

T = int(input())

for _ in range(T):
    k = int(input())
    novel = [0] + list(map(int, input().split()))
    dp = [[0] * (k + 1) for _ in range(k + 1)]

    for i in range(2, k + 1):
        for j in range(1, k + 1 - (i - 1)):
            dp[j][j + i - 1] = min(dp[j][j + n] + dp[j + n + 1][j + i - 1] for n in range(i - 1)) + sum(novel[j:j + i])

    print(dp[1][k])
```

### 준비

```py
import sys
input = sys.stdin.readline

T = int(input())

for _ in range(T):
    k = int(input())
    novel = [0] + list(map(int, input().split()))
    dp = [[0] * (k + 1) for _ in range(k + 1)]
```

dp 테이블을 준비하고 소설의 크기들을 준비한다.

### 풀이

```py
    for i in range(2, k + 1):
        for j in range(1, k + 1 - (i - 1)):
            dp[j][j + i - 1] = min(dp[j][j + n] + dp[j + n + 1][j + i - 1] for n in range(i - 1)) + sum(novel[j:j + i])

    print(dp[1][k])
```

첫 번째 for문은 간격을 설정해준다. 2부터 시작해서 k까지 모두 구한다.

두 번째 for문은 간격의 시작과 끝을 설정한다. 길이가 2일 때, [1][2], [2][3], [3][4] 처럼 구했던 것과 같은 과정이다. 쿼리 내용을 보면 min 함수 안에 for문이 들어 있다. for문은 각 간격의 중간 부분을 나누어서 구하기 위함이다. 예를 들어, 길이가 4일 때, `dp[1][1] + dp[2][4], dp[1][2] + dp[3][4], dp[1][3] + dp[4][4]` 이렇게 중간을 나눠준다. 끝나면 sum으로 다 더해주고 dp 테이블에 저장한다.

# 총평

뭔가 자존감이 꺾이는 문제였다 ㅠㅠ... bfs나 다익스트라는 잘 풀겠는데 dp는 생각해내기가 너무 어렵다. 이번 dp도 2차원 테이블을 통해 풀이하는 이런 방식이 익숙지 않다.

그래서 다이나믹 프로그래밍이 얼마나 부족한지 알았고, 다이나믹 프로그래밍 부분을 더 열심히 파서 익숙해져야겠다. 웹 공부하고 알고리즘 문제를 풀면 요즘은 딱 2문제 정도 푸는 것같다. 아무래도 어려운 문제를 풀려고 하다 보니까 더 못푸는 것 같다. 너무 자책하지 말고 정진하자.

![11066](https://user-images.githubusercontent.com/83271772/160862243-23172263-1f52-4acb-89bb-1323b02a352d.PNG)