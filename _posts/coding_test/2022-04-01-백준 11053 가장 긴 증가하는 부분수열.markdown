---
layout: post
title: "백준: 11053 가장 긴 증가하는 부분수열"
excerpt: "Python, DP"
date: 2022-04-01 23:35:00 +0900
categories:
  - Baekjoon
tags:
  - DP
---

- [문제](#문제)
- [입력](#입력)
- [출력](#출력)
- [예제 입력](#예제-입력)
- [예제 출력](#예제-출력)
- [문제 풀이](#문제-풀이)
  - [A. 접근](#a-접근)
  - [B. 코드 분석](#b-코드-분석)
    - [전체 코드](#전체-코드)
    - [B-1. 준비](#b-1-준비)
    - [B-2. 풀이](#b-2-풀이)
- [총평](#총평)

# 문제

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

# 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 $A_i$가 주어진다. (1 ≤ $A_i$ ≤ 1,000)

# 출력

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

# 예제 입력

```
6
10 20 10 30 20 50
```

# 예제 출력

```
4
```

# 문제 풀이

## A. 접근

11055 가장 큰 부분 증가 수열과 같은 풀이로 푸는 문제 2중 for문을 두어서 각 기준과, 그 기준 이전 까지 수열을 돌면서 값을 찾아낸다.

## B. 코드 분석

### 전체 코드

```py
import sys
input = sys.stdin.readline

N = int(input())
arr = list(map(int, input().split()))
d = [1] * N

for i in range(1, N):
    for j in range(i):
        if arr[j] < arr[i]:
            d[i] = max(d[i], d[j] + 1)

print(max(d))
```

### B-1. 준비

```py
import sys
input = sys.stdin.readline

N = int(input())
arr = list(map(int, input().split()))
d = [1] * N
```
모든 길이는 1부터 시작하므로 먼저 d의 모든 원소를 1로 초기화 해준다.

### B-2. 풀이

```py
for i in range(1, N):
    for j in range(i):
        if arr[j] < arr[i]:
            d[i] = max(d[i], d[j] + 1)

print(max(d))
```
수열을 1번 인덱스부터 N-1번 인덱스까지 돌면서 그 인덱스에서 가질 수 있는 가장 긴 인덱스를 찾는다. 이때 증가하는 수열이기 때문에 arr에서 두 값은 크고 작음이 확실해야 한다.

# 총평

너무 쉽다고 이게 진짜 내 실력이라고 생각하지 말자. 이건 풀이를 몸에 익히는 단계이다. 익숙해지면서 점점 더 어려운 문제를 잘 풀수 있게 되기를.

![11053](https://user-images.githubusercontent.com/83271772/161286005-ba84965e-d1b6-4ee1-ba76-8f03583683da.PNG)