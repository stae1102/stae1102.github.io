---
layout: post
title: "백준: 2240 자두나무"
excerpt: "Python, DP"
date: 2022-04-02 23:07:00 +0900
categories:
  - Baekjoon
tags:
  - DP
---

- [문제](#문제)
- [입력](#입력)
- [출력](#출력)
- [예제 입력](#예제-입력)
- [예제 출력](#예제-출력)
- [문제 풀이](#문제-풀이)
  - [A. 접근](#a-접근)
  - [B. 코드 분석](#b-코드-분석)
    - [전체 코드](#전체-코드)
    - [B-1. 준비](#b-1-준비)
    - [B-2. 풀이](#b-2-풀이)
- [총평](#총평)

# 문제

자두는 자두를 좋아한다. 그래서 집에 자두나무를 심어두고, 여기서 열리는 자두를 먹고는 한다. 하지만 자두는 키가 작아서 자두를 따먹지는 못하고, 자두가 떨어질 때까지 기다린 다음에 떨어지는 자두를 받아서 먹고는 한다. 자두를 잡을 때에는 자두가 허공에 있을 때 잡아야 하는데, 이는 자두가 말랑말랑하여 바닥에 떨어지면 못 먹을 정도로 뭉개지기 때문이다.

매 초마다, 두 개의 나무 중 하나의 나무에서 열매가 떨어지게 된다. 만약 열매가 떨어지는 순간, 자두가 그 나무의 아래에 서 있으면 자두는 그 열매를 받아먹을 수 있다. 두 개의 나무는 그다지 멀리 떨어져 있지 않기 때문에, 자두는 하나의 나무 아래에 서 있다가 다른 나무 아래로 빠르게(1초보다 훨씬 짧은 시간에) 움직일 수 있다. 하지만 자두는 체력이 그다지 좋지 못해서 많이 움직일 수는 없다.

자두는 T(1≤T≤1,000)초 동안 떨어지게 된다. 자두는 최대 W(1≤W≤30)번만 움직이고 싶어 한다. 매 초마다 어느 나무에서 자두가 떨어질지에 대한 정보가 주어졌을 때, 자두가 받을 수 있는 자두의 개수를 구해내는 프로그램을 작성하시오. 자두는 1번 자두나무 아래에 위치해 있다고 한다.

# 입력

첫째 줄에 두 정수 T, W가 주어진다. 다음 T개의 줄에는 각 순간에 자두가 떨어지는 나무의 번호가 1 또는 2로 주어진다.

# 출력

첫째 줄에 자두가 받을 수 있는 자두의 최대 개수를 출력한다.

# 예제 입력

```
7 2
2
1
1
2
2
1
1
```

# 예제 출력

```
6
```

# 문제 풀이

## A. 접근

이 문제는 이전 시점의 dp 테이블을 주목하는 문제이다.

이때 자두나무는 항상 두 개로 고정이다. 이때, 움직인 횟수와 자두나무를 연관지어 생각해보면, 한 번 움직였을 때는 무조건 2번 나무에 있고, 두 번 움직였을 때는 무조건 1번 나무에 있다.

즉, **홀수 번** 움직였을 때는 **2번 나무**에 있고, **짝수 번** 움직였을 때는 **1번 나무**에 있다.

이렇게 생각하면 문제에서 고려할 것이 확실히 줄어든다. 예제에서의 경우, 2초가 지났다고 한다면, ①계속 가만히 있는 경우와 ②1초에 움직이고 2초에는 가만히 있는 경우+1초에는 가만히 있고 2초에 움직이는 경우, ③1초에 움직이고 2초에도 움직이는 경우로 총 세 가지 경우가 있다.

①번은 1초에 가만히 있던 경우에 자두가 떨어진 경우를 더해주면 된다(`d[1][0] = d[0][0] + arr[1][0]` 여기서 arr[N][0]은 1번 위치에 자두가 떨어진 경우이고 arr[N][1]은 2번 위치에 자두가 떨어진 경우이다).

②번은 두 가지 경우 중 가장 큰 것을 고르면 된다. 왜냐하면 둘 다 모두 2번 나무에 있는 것이기 때문이다. 즉, d[1][1] = max(d[0][0], d[0][1]) + arr[1][1] 으로 구할 수 있다. 두 가지 경우 최종적으로 arr[1][1]을 더해주기 때문에 d만 최댓값을 찾으면 된다.

③번도 마찬가지로 가장 큰 것을 고른다. d[1][2] = max(d[0][1], d[0][2]) + arr[1][2]

이를 잘 고려해서 코드를 작성하도록 한다.

## B. 코드 분석

### 전체 코드

```py
import sys
input = sys.stdin.readline
t, w = map(int, input().split())

d = [[0] * (w + 1) for _ in range(t)]
tree = [[0, 0] for _ in range(t)]

for i in range(t):
    k = int(input())
    tree[i][k - 1] += 1

d[0][0] = tree[0][0]; d[0][1] = tree[0][1]

for i in range(1, t):
    d[i][0] = d[i-1][0] + tree[i][0]
    for j in range(1, w + 1):
        d[i][j] = max(d[i-1][j-1], d[i-1][j]) + tree[i][j % 2]

print(max(d[-1]))
```

### B-1. 준비

```py
import sys
input = sys.stdin.readline
t, w = map(int, input().split())

d = [[0] * (w + 1) for _ in range(t)]
tree = [[0, 0] for _ in range(t)]

for i in range(t):
    k = int(input())
    tree[i][k - 1] += 1

d[0][0] = tree[0][0]; d[0][1] = tree[0][1]
```

d에서 w + 1로 열의 개수를 정한 이유는, 안 움직인 경우를 포함해서 w + 1개의 움직인 경우가 있기 때문이다. tree는 1번 나무, 2번 나무의 경우가 있으므로 열의 개수를 두 개로 설정했다.

### B-2. 풀이

```py
for i in range(1, t):
    d[i][0] = d[i-1][0] + tree[i][0]
    for j in range(1, w + 1):
        d[i][j] = max(d[i-1][j-1], d[i-1][j]) + tree[i][j % 2]

print(max(d[-1]))
```
앞에서 접근한 대로 로직을 작성한다. 여기서 특이한 것은 `d[i][j] = max(d[i-1][j-1], d[i-1][j]) + tree[i][j % 2]` 이 부분인데, 짝수 횟수에서는 1에 위치하고, 홀수 위치에서는 짝수에 위치한다는 것을 토대로 이렇게 더한다.

# 총평

7분? 10분? 만에 풀어서 당황한 문제. 화이팅~

![2240](https://user-images.githubusercontent.com/83271772/161387876-ba201d30-af58-4763-aafb-8752799821ec.PNG)
