---
layout: post
title: "백준: 14501 퇴사"
excerpt: "Python, DP"
date: 2022-04-02 14:17:00 +0900
categoreis:
  - Baekjoon
tags:
  - DP
---

- [문제](#문제)
- [입력](#입력)
- [출력](#출력)
- [예제 입력](#예제-입력)
- [예제 출력](#예제-출력)
- [문제 풀이](#문제-풀이)
	- [A. 접근](#a-접근)
	- [B. 코드 분석](#b-코드-분석)
		- [전체 코드](#전체-코드)
		- [B-1. 준비](#b-1-준비)
		- [B-2. 풀이](#b-2-풀이)
- [총평](#총평)

# 문제

상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.

오늘부터 N+1일째 되는 날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.

백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다.

각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다.

N = 7인 경우에 다음과 같은 상담 일정표를 보자.

<table class="table table-bordered">
	<thead>
		<tr>
			<th>&nbsp;</th>
			<th>1일</th>
			<th>2일</th>
			<th>3일</th>
			<th>4일</th>
			<th>5일</th>
			<th>6일</th>
			<th>7일</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>T<sub>i</sub></th>
			<td>3</td>
			<td>5</td>
			<td>1</td>
			<td>1</td>
			<td>2</td>
			<td>4</td>
			<td>2</td>
		</tr>
		<tr>
			<th>P<sub>i</sub></th>
			<td>10</td>
			<td>20</td>
			<td>10</td>
			<td>20</td>
			<td>15</td>
			<td>40</td>
			<td>200</td>
		</tr>
	</tbody>
</table>

1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다.

상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다. 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다.

또한, N+1일째에는 회사에 없기 때문에, 6, 7일에 있는 상담을 할 수 없다.

퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이때의 이익은 10+20+15=45이다.

상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.

# 입력

첫째 줄에 N (1 ≤ N ≤ 15)이 주어진다.

둘째 줄부터 N개의 줄에 Ti와 Pi가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ $T_i$ ≤ 5, 1 ≤ $P_i$ ≤ 1,000)

# 출력

첫째 줄에 백준이가 얻을 수 있는 최대 이익을 출력한다.

# 예제 입력

```
10
5 50
4 40
3 30
2 20
1 10
1 10
2 20
3 30
4 40
5 50
```

# 예제 출력

```
90
```

# 문제 풀이

## A. 접근

모든 날짜에서 받을 수 있는 최댓값을 계속해서 갱신해준다. for문으로 배열들을 순회하면서, 카운트 변수가 가르키는 시점에서 소요될 날짜 뒤의 날에 값을 갱신해준다.

예를 들어서,

```
1   2   3   4   5   6   7
3   5   1   1   2   4   2
10  20  10  20  15  40  200
```
이 상태에서 i = 1일 때, 1 + 3 - 1 = 3일에서 받을 수 있는 봉급은 10이다. 이때 -1을 해주는 이유는 그 날짜를 포함해서 계산해야 하기 때문이다. 계속해서 카운트하며 비교해보자.

```
1   2   3   4   5   6   7
3   5   1   1   2   4   2
10  20  10  20  15  40  200
0   0   10  0   0   0   0
```
i = 2일 때는 6일차에 받을 수 있는 봉급이 20이다. 아직 6일차는 봉급을 받지 않은 미래시점이다. 미리 기록해놓자.

```
1   2   3   4   5   6   7
3   5   1   1   2   4   2
10  20  10  20  15  40  200
0   0   10  0   0   20   0
```
i = 3일 때는 당일 날 일해서 10을 받을 수 있다. 그런데, 1일차에 일을 시작했을 때와 3일차에 일했을 때와 값이 같기 때문에 둘 중 더 큰 값으로 초기화해준다.

```
1   2   3   4   5   6   7
3   5   1   1   2   4   2
10  20  10  20  15  40  200
0   0   10  0   0   20   0
```
i = 4일 때는 당일 날 일해서 20을 받을 수 있다. 하지만, 3일차에 일을 끝내놔서 이미 10을 받은 상태이다. 그래서 4일차에 받을 수 있는 급여는 30이다.

이때 우리가 3일차에 일한 돈을 고려해서 초기화하기 위해서 다음과 같이 코드를 작성하도록 한다.

```
d[끝나는 날짜] = max(d[끝나는 날짜], arr[오늘의 급여(끝나는 날짜에 받을 급여)] + d[어제의 급여])
```

이렇게 로직을 작성하면, d[4] = 30이 된다.

```
1   2   3   4   5   6   7
3   5   1   1   2   4   2
10  20  10  20  15  40  200
0   0   10  30  0  20   0
```

i = 5일 때는 d[4]가 30이고, d[7]은 0이기 때문에, d[7]을 d[4] + arr[5]로 초기화한다.

```
1   2   3   4   5   6   7
3   5   1   1   2   4   2
10  20  10  20  15  40  200
0   0   10  30  0   20  45
```

그렇다면 i = 6일 때는 받을 수 있는 돈이 애매해진다. 오늘부터 일하면 퇴사날보다 더 일해야 해서 돈을 못 받기 때문에, 미리 저장해 두었던 d[6]의 값 만큼만 급여를 받게 된다.

이것은 매번 최댓값으로 급여들을 갱신해주지 않았기 때문이다. 즉, 5일차에 확보한 급여는 4일차에 받았던 30이기 때문에 d[5]도 30으로 갱신해주어야 한다.

그렇기 때문에 `d[끝나는 날짜] = max(d[끝나는 날짜], arr[오늘의 급여(끝나는 날짜에 받을 급여)] + d[어제의 급여])`의 계산이 끝난 후에 i > 0일 때 `d[i] = max(d[i], d[i - 1])`로 값을 최대로 만들어준다.

이번 사례에서 직접적으로 중요한 포인트처럼 보이지 않으나, 다른 케이스의 경우에 이것이 매우 중요하다.

```
1 2 3 4 5
3 3 3 3 1
5 2 4 5 1
0 0 0 0 0
```
이런 경우에
```
1 2 3 4 5
3 3 3 3 1
5 2 4 5 1
0 0 5 2 4
```

이렇게 계산이 되어서 3일차에 일한 급여가 최댓값인데, 5일차에는 3일차에 시작한 일이 최대로 받을 수 있는 급여로 계산이 되어 4밖에 받지 못한다. 엄청난 손해다. 그렇기 때문에, 매번 d[i] = max(d[i], d[i - 1])로 초기화한다. (매번 max(d[:i])로 해도 되지만, 전체를 순회하는 것보다 이게 더 빠르니까!)

## B. 코드 분석

### 전체 코드

```py
import sys
input = sys.stdin.readline
N = int(input())

arr = [list(map(int, input().split())) for _ in range(N)]

d = [0] * N

for i in range(N):
    if i + arr[i][0] - 1 < N:
        d[i + arr[i][0] - 1] = max(d[i + arr[i][0] - 1], arr[i][1] + d[i - 1])
    if i > 0:
        d[i] = max(d[i], d[i - 1])

print(d[-1])
```

### B-1. 준비

```py
import sys
input = sys.stdin.readline
N = int(input())

arr = [list(map(int, input().split())) for _ in range(N)]

d = [0] * N
```

### B-2. 풀이

```py
for i in range(N):
    if i + arr[i][0] - 1 < N:
        d[i + arr[i][0] - 1] = max(d[i + arr[i][0] - 1], arr[i][1] + d[i - 1])
    if i > 0:
        d[i] = max(d[i], d[i - 1])

print(d[-1])
```

아까의 사고방식을 코드로 구현했다.

# 총평

이 문제를 4시간이나 풀 줄이야... 난 바보다.... 문제 이름이 퇴사라서 나도 퇴사하고 싶더라..취준생이지만

![14501](https://user-images.githubusercontent.com/83271772/161368645-2c72148d-9280-489a-900a-2b99cd52096a.PNG)