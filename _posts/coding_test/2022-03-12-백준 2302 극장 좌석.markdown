---
layout: post
title: "백준: 2302 극장 좌석"
excerpt: "Python, DP"
date: 2022-03-12 22:00:00 +0900
categories:
  - Baekjoon
tags:
  - DP
---

- [문제](#문제)
- [입력](#입력)
- [출력](#출력)
- [제한](#제한)
- [문제풀이](#문제풀이)
  - [A. 아이디어](#a-아이디어)
  - [B. 코드 분석](#b-코드-분석)
    - [전체 코드](#전체-코드)
    - [B-1. 변수 설정](#b-1-변수-설정)
    - [B-2. 정답 계산](#b-2-정답-계산)
- [총평](#총평)

# 문제

어떤 극장의 좌석은 한 줄로 되어 있으며 왼쪽부터 차례대로 1번부터 N번까지 번호가 매겨져 있다. 공연을 보러 온 사람들은 자기의 입장권에 표시되어 있는 좌석에 앉아야 한다. 예를 들어서, 입장권에 5번이 쓰여 있으면 5번 좌석에 앉아야 한다. 단, 자기의 바로 왼쪽 좌석 또는 바로 오른쪽 좌석으로는 자리를 옮길 수 있다. 예를 들어서, 7번 입장권을 가진 사람은 7번 좌석은 물론이고, 6번 좌석이나 8번 좌석에도 앉을 수 있다. 그러나 5번 좌석이나 9번 좌석에는 앉을 수 없다.

그런데 이 극장에는 “VIP 회원”들이 있다. 이 사람들은 반드시 자기 좌석에만 앉아야 하며 옆 좌석으로 자리를 옮길 수 없다.

오늘 공연은 입장권이 매진되어 1번 좌석부터 N번 좌석까지 모든 좌석이 다 팔렸다. VIP 회원들의 좌석 번호들이 주어졌을 때, 사람들이 좌석에 앉는 서로 다른 방법의 가짓수를 구하는 프로그램을 작성하시오.

예를 들어서, 그림과 같이 좌석이 9개이고, 4번 좌석과 7번 좌석이 VIP석인 경우에 <123456789>는 물론 가능한 배치이다. 또한 <213465789> 와 <132465798> 도 가능한 배치이다. 그러나 <312456789> 와 <123546789> 는 허용되지 않는 배치 방법이다.

<p align="center"><img src="https://upload.acmicpc.net/80caa675-30d4-44ec-8100-01f8eac2a3e3/-/preview/" width="50%"></p>

# 입력

첫째 줄에는 좌석의 개수 N이 입력된다. N은 1 이상 40 이하이다. 둘째 줄에는 고정석의 개수 M이 입력된다. M은 0 이상 N 이하이다. 다음 M 개의 줄에는 고정석의 번호가 작은 수부터 큰 수의 순서로 한 줄에 하나씩 입력된다.

# 출력

주어진 조건을 만족하면서 사람들이 좌석에 앉을 수 있는 방법의 가짓수를 출력한다. 방법의 가짓수는 2,000,000,000을 넘지 않는다. (2,000,000,000 < 231-1)

# 제한

* 1 ≤ N ≤ 100,000

* 0 ≤ M ≤ 2,000,000,000

* 0 ≤ |A[i]| ≤ 1,000,000,000

# 문제풀이

## A. 아이디어

DP가 안 풀릴 때는 처음부터 천천히 계산해보며 규칙을 찾아낸다. 극장 좌석의 경우, 자리가 교체 가능한 가짓수를 모두 나열해본다.

만약에 자리가 1개면 바꿀 수 없으므로 1개, 자리가 2개면 좌우로 바꿀 수 있으므로 2개, 자리가 세 개면 3...

```
1 // (1, )
2 // (1, 2), (2, 1)
3 // (1, 2, 3), (2, 1, 3), (1, 3, 2)
4 // (1, 2, 3, 4), (2, 1, 3, 4), (1, 3, 2, 4), (1, 2, 4, 3), (2, 1, 4, 3)
...
```
일단 수의 흐름을 보아도 1 -> 2 -> 3 -> 5 로 피보나치의 낌새를 가지고 있다. 이런 상태로 위 규칙을 다시 보면, 맨 끝 자리를 바꾸느냐 안 바꾸느냐로 다음 가능한 경우의 수를 확인할 수 있다.

예를 들어 4개의 좌석이 있는 경우에는 맨 뒤 좌석이 변하지 않는 경우에 3개의 좌석이 있을 때의 순서에서 맨 뒤에 4를 넣어주면 총 3가지 경우가 있으며, 맨 뒤 좌석이 변하는 경우 즉, (x, x, 4, 3)으로 된 경우에는 2번의 경우에 4를 붙이고( 1, 2, 4, x / 2, 1, 4, x) 맨 뒤 좌석을 3으로 만들어주면 총 2가지 경우가 있다고 볼 수 있다.

따라서, dp[i] = dp[i - 2] + dp[i - 1] (i > 2) 라고 점화식을 세울 수 있다.

🔥다이나믹 프로그래밍은 점화식이 매우 중요하다!!🔥

## B. 코드 분석

### 전체 코드

```python
import sys
input = sys.stdin.readline
n = int(input())
m = int(input())

vips = [int(input()) for _ in range(m)]

dp = [0] * (n + 1)
dp[0] = 1
dp[1] = 1
dp[2] = 2

for i in range(3, n + 1):
    dp[i] = dp[i - 1] + dp[i - 2]

ans = 1

if m > 0:
    temp = 0
    for i in range(m):
        ans *= dp[vips[i] - temp - 1]
        temp = vips[i]
    ans *= dp[n - temp]
else:
    ans = dp[n]
print(ans)
```
### B-1. 변수 설정

```python
import sys
input = sys.stdin.readline
n = int(input())
m = int(input())

vips = [int(input()) for _ in range(m)]

dp = [0] * (n + 1)
dp[0] = 1
dp[1] = 1
dp[2] = 2

for i in range(3, n + 1):
    dp[i] = dp[i - 1] + dp[i - 2]

ans = 1
```
여기서 고려할 것은 vip 좌석이다. vip 좌석을 분리시키면 각 좌석의 집합이 서로 비동기적이므로 곱의 법칙을 따라야 한다. 이 부분은 일단 보류하고 dp 테이블을 세팅한다. dp[0]이 중요한 이유는 모든 좌석이 vip인 경우 때문에 설정했다.

### B-2. 정답 계산

```python
ans = 1

if m > 0:
    temp = 0
    for i in range(m):
        ans *= dp[vips[i] - temp - 1]
        temp = vips[i]
    ans *= dp[n - temp]
else:
    ans = dp[n]
print(ans)
```

vip 좌석이 없을 수도 있고, 있을 수도 있다. 그래서 m > 0으로 vip 좌석이 하나라도 있는 경우와 없는 경우를 분리했다. vip 좌석이 하나라도 있으면 먼저 temp 변수로 임시변수가 필요하다. 이는 부분합과 비슷한 경우이다.

temp가 0일 때는 처음부터 vip 좌석 전까지를 고려한다. 그래서 dp[vips[i] - temp - 1]에서 1을 빼준 이유이기도 하다. 입력 예시에서 4번 좌석에 vip가 있었는데, 이를 사용해서 계산해보면 4번 좌석 전까지 1, 2, 3번 좌석은 3가지 경우의 수로 자리를 변경할 수 있다. 그 다음으로 vip였던 위치를 temp 변수로 저장한다. 이러면 vip와 다음 vip 까지의 좌석 갯수를 찾아내는 데에 도움이 된다.

마지막에 vip 좌석이 끝난 경우가 있어서 ans에 한 번 더 구해줬다. 마지막 자리가 vip여도 어차피 n - temp는 0이고, dp[0]은 1이기 때문에 상관없다.

# 총평

솔직히 아이디어가 정말 찾기 어렵지, 막상 아이디어만 구상하면 참 쉬운 알고리즘이 dp인 것 같다. 점화식 원툴이랄까...?

![2302](https://user-images.githubusercontent.com/83271772/158021976-2a1ec60e-2448-4a21-a034-dd619f71c2ca.PNG)
