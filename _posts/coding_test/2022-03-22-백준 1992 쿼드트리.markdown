---
layout: post
title: "백준: 1992 쿼드트리"
excerpt: "Python, Divide & Conquer"
date: 2022-03-22 23:25:00 +0900
categories:
  - Baekjoon
tags:
  - Divide & Conquer
---

# 문제

흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있다.

주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 "0"이 되고, 모두 1로만 되어 있으면 압축 결과는 "1"이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다

<p align='center'><img src='https://www.acmicpc.net/JudgeOnline/upload/201007/qq.png'></p>

위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며, 이 영상을 쿼드 트리 구조를 이용하여 압축하면 "(0(0011)(0(0111)01)1)"로 표현된다.  N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오.

# 입력

첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1 ≤ N ≤ 64의 범위를 가진다. 두 번째 줄부터는 길이 N의 문자열이 N개 들어온다. 각 문자열은 0 또는 1의 숫자로 이루어져 있으며, 영상의 각 점들을 나타낸다.

# 출력

영상을 압축한 결과를 출력한다.

# 예제 입력 1

```
8
11110000
11110000
00011100
00011100
11110000
11110000
11110011
11110011
```

# 예제 출력 1

```
((110(0101))(0010)1(0001))
```

# 문제 풀이

## A. 아이디어

Simple is the Best. 오늘도 지키지 못했다... 코드 풀이가 생각보다 너무 심플하더라. 쿼드트리가 압축해서 저장하는 것인데 이것을 생각을 못해서 계속 틀렸던 것 같다. 조건을 파악하는 게 좀 어려웠다. 그래프 체크를 범위를 총 합하여 더해서 조건을 확인했는데, 그렇게 하는 것보다, 하나라도 틀리면 체크 범위를 분할해서 체크해야 했다.

## B. 코드 분석

### 전체 코드

```py
import sys
input = sys.stdin.readline
n = int(input())
graph = [list(map(int, list(input().rstrip()))) for _ in range(n)]

def quad(x, y, n):
    check = graph[x][y]
    for a in range(x, x + n):
        for b in range(y, y + n):
            if check != graph[a][b]:
                print('(', end='')
                quad(x, y, n // 2)
                quad(x, y + n// 2, n // 2)
                quad(x + n // 2, y, n // 2)
                quad(x + n // 2, y + n // 2, n // 2)
                print(')', end='')
                return
        
    if check == 0:
        print(0, end='')
        return
    else:
        print(1, end='')
        return

quad(0, 0, n)
```

### B-1. 준비

```py
import sys
input = sys.stdin.readline
n = int(input())
graph = [list(map(int, list(input().rstrip()))) for _ in range(n)]
```

그래프를 준비한다. 공백으로 구분하지 않기 때문에 그냥 input을 받고, sys 모듈로 입력받기 때문에 개행문자를 제거하기 위해 rstrip()은 꼭 붙인다.

### B-2. 풀이 및 출력

```py
def quad(x, y, n):
    check = graph[x][y]
    for a in range(x, x + n):
        for b in range(y, y + n):
            if check != graph[a][b]:
                print('(', end='')
                quad(x, y, n // 2)
                quad(x, y + n// 2, n // 2)
                quad(x + n // 2, y, n // 2)
                quad(x + n // 2, y + n // 2, n // 2)
                print(')', end='')
                return
        
    if check == 0:
        print(0, end='')
        return
    else:
        print(1, end='')
        return

quad(0, 0, n)
```

먼저 체크의 대상을 정해준다. 입력 좌표로부터 탐색하기 때문에 입력 좌표를 기준으로 다른 값이 나올 때 다시 분할 탐색을 하는 로직으로 분할 정복한다.

그래프가 분할하면 그 때는 압축해서 표현하지 못한 것이므로 처음 시작에서 (를 붙이고 마지막에 )를 붙인다.

# 총평

분할 정복이 좀 부족한 것같다. 가장 부족한 것은 **조건 체크**이다. 어떤 조건일 때 분할하고 어떤 조건일 때 분할하면 안되는 지를 조금 명확하게 구분하자.

함수 **시작의 스케일**을 잘 조정하자. 맨 처음에 n // 2로 좌상, 우상, 좌하, 우하로 순회했었는데, 문제 조건이 전체를 스캔해서 하나의 값으로 압축할 수 있는지 표현하는 것이라서 전체를 먼저 순회해야 했다.

분할 정복이 부족하다는 점을 알았다 오히려 좋아!

![1992](https://user-images.githubusercontent.com/83271772/159506778-75f63174-5bd9-46a2-a9dd-4b586060a8c1.PNG)