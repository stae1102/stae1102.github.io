---
layout: post
title: "백준: 1149 RGB거리"
excerpt: "Python, DP"
date: 2022-03-31 23:42:00 +0900
categories:
  - Baekjoon
tags:
  - DP
---

- [문제](#문제)
- [입력](#입력)
- [출력](#출력)
- [예제 입력](#예제-입력)
- [예제 출력](#예제-출력)
- [문제 풀이](#문제-풀이)
  - [A. 접근](#a-접근)
  - [B. 코드 분석](#b-코드-분석)
    - [전체 코드](#전체-코드)
    - [B-1. 준비](#b-1-준비)
    - [B-2. 풀이](#b-2-풀이)
- [총평](#총평)

# 문제

RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

* 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
* N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
* i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

# 입력

첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.

# 출력

첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

# 예제 입력

```
6
30 19 5
64 77 64
15 19 97
4 71 57
90 86 84
93 32 91
```

# 예제 출력

```
208
```

# 문제 풀이

## A. 접근

DP 응용 문제에서는 2차원 리스트가 많이 쓰인다. 이번 문제도 그렇다. 내가 i번째 집의 색깔을 고른다면 i - 1번째의 색을 고려하여 색깔을 정해야 한다.

예를 들어

```
3
        R  G  B
       _________
i = 1 | 26 40 83
i = 2 | 49 60 57
i = 3 | 13 89 99
```

이렇게 되어 있을 때, i = 2일 때 R을 고른다면, i = 1에서는 G인 40 혹은 B인 83을 골라야 한다. 그렇다면 dp 테이블에서 dp[2][0] 은 dp[2-1][1], dp[2-1][2] 중에서 가장 작은 값을 고르고 그 값과 i = 2일 때 R의 값을 더해준다. 그렇게 dp[2][0]을 저장하면, 다음 dp[3]에서 가장 작은 값을 고를 때 사용할 수 있게 된다.

i = 1은 앞에서 고를 수 있는 값이 없기 때문에, dp가 0부터 시작하도록 해준다. 그렇게 되면, i = 1일 때는 본인을 값으로 지정하게 된다.

## B. 코드 분석

### 전체 코드

```py
import sys
input = sys.stdin.readline
N = int(input())
dp = [[0] * 3 for _ in range(N + 1)]

RGB = [[0] * 3 for _ in range(N + 1)]
RGB[1:] = [list(map(int, input().split())) for _ in range(N)]

for i in range(1, N + 1):
    dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + RGB[i][0]
    dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + RGB[i][1]
    dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + RGB[i][2]

print(min(dp[N][0], dp[N][1], dp[N][2]))
```

### B-1. 준비

```py
import sys
input = sys.stdin.readline
N = int(input())
dp = [[0] * 3 for _ in range(N + 1)]

RGB = [[0] * 3 for _ in range(N + 1)]
RGB[1:] = [list(map(int, input().split())) for _ in range(N)]
```
dp 테이블은 0부터 시작하도록 만들어주고, RGB 값도 동일하게 0부터 시작하도록 만들어준다.

### B-2. 풀이

```py
for i in range(1, N + 1):
    dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + RGB[i][0]
    dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + RGB[i][1]
    dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + RGB[i][2]

print(min(dp[N][0], dp[N][1], dp[N][2]))
```

dp[i][0]일 때는 이전 값들인 dp[i-1][1]과 dp[i-1][2] 중에서 가장 작은 값을 골라준다. 왜냐하면, 계속해서 최솟값을 저장해두기 때문에 둘 중 하나를 골라 저장하는 경우, 그 값 또한 최솟값이 되기 때문이다.

# 총평

풀고 나면 참 쉬운데 풀기가 너무 어렵다. 저번 파일합치기처럼 문제를 접근했는데 그것도 아니었다. 문제를 풀 때, 표처럼 데이터를 나타내서 풀이하는 게 크게 봤을 때 더 좋은 접근인 것 같다.

![1149](https://user-images.githubusercontent.com/83271772/161086083-99e04069-adca-4a52-bea0-580b1531d3ab.PNG)