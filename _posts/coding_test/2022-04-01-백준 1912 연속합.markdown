---
layout: post
title: "백준: 1912 연속합"
excerpt: "Python, DP"
date: 2022-04-01 20:41:00 +0900
categories:
  - Baekjoon
tags:
  - DP
---

- [문제](#문제)
- [입력](#입력)
- [출력](#출력)
- [예제 입력](#예제-입력)
- [예제 출력](#예제-출력)
- [문제 풀이](#문제-풀이)
  - [A. 접근](#a-접근)
  - [B. 코드 분석](#b-코드-분석)
    - [전체 코드](#전체-코드)
    - [B-1. 준비](#b-1-준비)
    - [B-2. 풀이](#b-2-풀이)
- [총평](#총평)

# 문제

n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.

예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.

# 입력

첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

# 출력

첫째 줄에 답을 출력한다.

# 예제 입력

```
10
10 -4 3 1 5 6 -35 12 21 -1
```

# 예제 출력

```
33
```

# 문제 풀이

## A. 접근

문제를 어떻게 풀어야 하나 고민을 했는데, 이전 값을 참고한다는 점에서 1차원 리스트로 충분할 것같다는 결론 하에 문제를 풀었다. arr[i - 1] + arr[i]와 arr[i]를 비교하여 arr[i]가 더 크다면 연속합을 멈추고 현재의 값으로 연속합을 대체한다.

## B. 코드 분석

### 전체 코드

```py
import sys
input = sys.stdin.readline

N = int(input())
arr = list(map(int, input().split()))

ans = arr[0]

for i in range(1, N):
    arr[i] = max(arr[i - 1] + arr[i], arr[i])
    ans = max(ans, arr[i])

print(ans)
```

### B-1. 준비

```py
import sys
input = sys.stdin.readline

N = int(input())
arr = list(map(int, input().split()))

ans = arr[0]
```
이 문제에서 챙겨야 할 포인트는 한 개 이상의 연속합이라는 것이다. 즉, 한 개더라도 합으로 간주한다. 그래서, 답으로 제출할 ans 변수를 arr의 첫 원소로 초기화했다.

### B-2. 풀이

```py
for i in range(1, N):
    arr[i] = max(arr[i - 1] + arr[i], arr[i])
    ans = max(ans, arr[i])

print(ans)
```

두 번째 원소부터 돌며 이전 값과의 합과 현재 값을 비교한다. 그래서 더 큰 값으로 arr에 넣어주고 최댓값을 계속해서 갱신해준다.

# 총평

점점 발전하고 있다.

이전 값이 리스트 형태라면 2차원 리스트, 이전 값이 스칼라 형태라면 1차원 리스트로 접근하는 방법이 좋아보인다.

![1912](https://user-images.githubusercontent.com/83271772/161262358-1fa36f08-737d-4f16-8200-90386cf99c21.PNG)