---
layout: post
title: "백준: 2156 포도주 시식"
excerpt: "Python, DP"
categories:
  - Baekjoon
tags:
  - DP
---

- [문제](#문제)
- [입력](#입력)
- [출력](#출력)
- [예제 입력](#예제-입력)
- [예제 출력](#예제-출력)
- [문제 풀이](#문제-풀이)
  - [A. 접근](#a-접근)
    - [A-1. 안 마신 경우](#a-1-안-마신-경우)
    - [A-2. 한 번 마신 경우](#a-2-한-번-마신-경우)
    - [A-2. 연속으로 두 번 마신 경우](#a-2-연속으로-두-번-마신-경우)
  - [B. 코드 분석](#b-코드-분석)
    - [전체 코드](#전체-코드)
    - [B-1. 준비](#b-1-준비)
    - [B-2. 풀이](#b-2-풀이)
- [총평](#총평)

# 문제

효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.

1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오. 

예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.

# 입력

첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.

# 출력

첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.

# 예제 입력

```
6
6
10
13
9
8
1
```

# 예제 출력

```
33
```

# 문제 풀이

## A. 접근

이전 시점의 값을 받아와서 매번 최댓값을 갱신하는 류의 문제이다.

또한, 각 시점마다 횟수가 존재하기 때문에 2차원 리스트로 dp 테이블을 갱신하도록 한다. 이때, 횟수는 연속해서 마신 횟수로 지정했다. 그렇다면 매 시점 어떻게 갱신해야 할까?

### A-1. 안 마신 경우
먼저 그 시점에서 안 마신 경우가 있는데 이 경우 최댓값은, 이전 시점에 마시지 않은 경우 + 이전 시점에 한 번 마신 경우 + 이전 시점에서 연속으로 두 번 마신 경우 중 하나이다. 즉, `d[i][0] = max(d[i-1])`와 같이 갱신하도록 한다.

### A-2. 한 번 마신 경우

이 경우에는 이전 시점에서 안 마셨을 경우에 가능하다. 즉, `d[i][1] = d[i-1][0] + arr[i]`이다.

### A-2. 연속으로 두 번 마신 경우
이 경우에는 이전 시점에서 한 번 마셨을 경우에 가능하다. 즉, `d[i][2] = d[i-1][1] + arr[i]`이다.

## B. 코드 분석

### 전체 코드

```py
import sys
input = sys.stdin.readline
n = int(input())

wine = [[0, 0, 0] for _ in range(n)]
wine[0] = [0, int(input()), 0]

for i in range(1, n):
    k = int(input())
    wine[i][0] = max(wine[i-1])
    wine[i][1] = wine[i-1][0] + k
    wine[i][2] = wine[i-1][1] + k

print(max(wine[-1]))
```

### B-1. 준비

```py
import sys
input = sys.stdin.readline
n = int(input())

wine = [[0, 0, 0] for _ in range(n)]
wine[0] = [0, int(input()), 0]
```

첫 번째는 이전 시점이 존재하지 않기 때문에 미리 갱신해놓은 상태로 시작한다.

### B-2. 풀이

```py
for i in range(1, n):
    k = int(input())
    wine[i][0] = max(wine[i-1])
    wine[i][1] = wine[i-1][0] + k
    wine[i][2] = wine[i-1][1] + k

print(max(wine[-1]))
```

접근에서의 발상을 그대로 구현했다.

# 총평

이제 실버 단계 dp는 웬만하면 10분 안에 푸는 것 같다. 무~야~호~

![2156](https://user-images.githubusercontent.com/83271772/161418596-61c4118e-db82-4f01-ad1f-bc237e08c312.PNG)