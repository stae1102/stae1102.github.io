---
layout: post
title:  "06 Mar TIL: NodeJS fs 메서드, 이벤트 이해, 예외 처리"
excerpt: "fs method, event, exception"
date:   2022-03-06 16:00:00 +0900
categories: 
  - Study
tags:
  - TIL
---

## 3.6.3 기타 fs 메서드 알아보기

* fs.access(경로, 옵션, 콜백): 폴더나 파일에 접근할 수 있는지 체크한다. 두 번째 인수로 상수들(constants)을 넣었는데, F_OK는 파일 존재 여부, R_OK는 읽기 권한 여부, W_OK는 쓰기 권한 여부를 체크한다. 파일/폴더나 권한이 없다면 에러가 발생하는데 파일/폴더가 없을 때의 에러 코드는 ENOENT이다.

* fs.mkdir(경로, 콜백): 폴더를 만드는 메서드이다. 이미 폴더가 있다면 에러가 발생하므로 먼저 access 메서드를 호출해서 확인하는 것이 중요하다.

* fs.open(경로, 옵션, 콜백): 파일의 아이디(fd 변수)를 가져오는 메서드이다. 파일이 없다면 파일을 생성한 뒤 아이디를 가져온다. 가져온 아이디를 사용해 fs.read나 fs.write를 통해 읽거나 쓸 수 있다. 두 번째 인수로 어떤 동작을 할 것인지를 설정할 수 있다. **쓰려면 w, 읽으려면 r, 기존 파일에 추가하려면 a를 입력한다.** 앞의 예제에서는 w를 했으므로 파일이 없을 때 새로 만들 수 있고, 만약 r이었다면 에러가 발생한다.

* fs.rename(기존 경로, 새 경로, 콜백): 파일의 이름을 바꾸는 메서드이다. 기존 파일 위치와 새로운 파일 위치를 적으면 된다. 같은 폴더를 지정할 필요가 없기 때문에 잘라내기 기능을 할 수도 있다.

<폴더 내용 확인 및 삭제 관련 메서드>

* fs.readdir(경로, 콜백): 폴더 안의 내용물을 확인할 수 있다. 배열 안에 내부 파일과 폴더명이 나온다.

* fs.unlink(경로, 콜백): 파일을 지울 수 있다. 파일이 없다면 에러가 발생하므로 먼저 파일이 있는지 꼭 확인해야 한다.

* fs.rmdir(경로, 콜백): 폴더를 지울 수 있다. 폴더 안에 파일들이 있다면 에러가 발생하므로 먼저 내부 파일을 모두 지우고 호출해야 한다.

노드 8.5 버전 이후에는 createReadStream과 createWriteStream을 pipe 하지 않아도 파일을 복사할 수 있다.

```js
const fs = require('fs').promises;

fs.copyFile('readme4.txt', 'writeme4.txt')
    .then(() => {
        console.log('복사 완료');
    })
    .catch((error) => {
        console.error(error);
    });
```

첫 번째 인수로 복사할 파일을, 두 번째 인수로 복사될 경로를, 세 번째 인수로 복사 후 실행될 콜백 함수를 입력한다.

마지막으로 파일/폴더의 변경 사항을 감지할 수 있는 watch 메서드이다.

```js
const fs = require('fs');

fs.watch('./target.txt', (eventType, filename) => {
    console.log(eventType, filename);
});
```

## 3.6.4 스레드풀 알아보기

fs 메서드를 여러 번 실행해도 백그라운드에서 동시에 처리되는데, 바로 스레드풀이 있었기 때문이다.

fs 외에도 내부적으로 스레드풀을 사용하는 모듈로는 crypto, zlib, dns, lookup 등이 있다.

```js
const crypto = require('crypto');

const pass = 'pass';
const salt = 'salt';
const start = Date.now();

crypto.pbkdf2(pass, salt, 100000, 128, 'sha512', () => {
    console.log('1:', Date.now() - start);
});

crypto.pbkdf2(pass, salt, 100000, 128, 'sha512', () => {
    console.log('2:', Date.now() - start);
});

crypto.pbkdf2(pass, salt, 100000, 128, 'sha512', () => {
    console.log('3:', Date.now() - start);
});

crypto.pbkdf2(pass, salt, 100000, 128, 'sha512', () => {
    console.log('4:', Date.now() - start);
});

crypto.pbkdf2(pass, salt, 100000, 128, 'sha512', () => {
    console.log('5:', Date.now() - start);
});

crypto.pbkdf2(pass, salt, 100000, 128, 'sha512', () => {
    console.log('6:', Date.now() - start);
});

crypto.pbkdf2(pass, salt, 100000, 128, 'sha512', () => {
    console.log('7:', Date.now() - start);
});

crypto.pbkdf2(pass, salt, 100000, 128, 'sha512', () => {
    console.log('8:', Date.now() - start);
});
```
실행할 때마다 시간과 순서가 달라진다. 스레드풀이 작업을 동시에 실행하기 때문인데, 1~4끼리는 묶여있고, 5~8끼리 묶여있다. **기본적으로 스레드 풀의 개수가 네 개이기 때문이다.**

스레드풀의 개수를 조절할 수도 있다. 윈도의 명령 프롬프트에서 SET UV_THREADPOOL_SIZE=1을 입력하는 것이다.

# 3.7 이벤트 이해하기

```js
const EventEmitter = require('events');

const myEvent = new EventEmitter();
myEvent.addListener('event1', () => {
    console.log('이벤트 1');
});
myEvent.on('event2', () => {
    console.log('이벤트 2');
});
myEvent.on('event2', () => {
    console.log('이벤트 2 추가');
});
myEvent.once('event3', () => {
    console.log('이벤트 3');
}); // 한 번만 실행됨

myEvent.emit('event1'); // 이벤트 호출
myEvent.emit('event2'); // 이벤트 호출

myEvent.emit('event3'); // 이벤트 호출
myEvent.emit('event3'); // 실행 안 됨

myEvent.on('event4', () => {
    console.log('이벤트 4');
});
myEvent.removeAllListeners('event4');
myEvent.emit('event4'); // 실행 안 됨

const listener = () => {
    console.log('이벤트 5');
};
myEvent.on('event5', listener);
myEvent.removeListener('event5', listener);
myEvent.emit('event5'); // 실행 안 됨

console.log(myEvent.listenerCount('event2'));
```

* on(이벤트명, 콜백): 이벤트 이름과 이벤트 발생 시의 콜백을 연결한다. 이렇게 연결하는 동작을 이벤트 리스닝이라고 부른다. event2처럼 이벤트 하나에 이벤트 여러 개를 달아줄 수도 있다.

* addListener(이벤트명, 콜백): on과 기능이 같다.

* emit(이벤트명): 이벤트를 호출하는 메서드. 이벤트 이름을 인수로 넣으면 미리 등록해뒀던 이벤트 콜백이 실행

* once(이벤트명, 콜백): 한 번만 실행되는 이벤트

* removeAllListeners(이벤트명): 이벤트에 연결된 모든 이벤트 리스너를 제거한다.

* removeListner(이벤트명, 리스너): 이벤트에 연결된 리스너를 하나씩 제거한다. **리스너를 넣어야 한다!**

* off(이벤트명, 콜백): removeListener와 기능이 같다.

* listenerCount(이벤트명): 현재 리스너가 몇 개 연결되어 있는지 확인

# 3.8 예외 처리하기

멀티 스레드 프로그램에서는 스레드 하나가 멈추면 그 일을 다른 스레드가 대신한다. 하지만 노드의 메인 스레드는 하나뿐이므로 그 하나를 소중히 보호해야 한다. 메인 스레드가 멈춘다는 것은 스레드를 갖고 있는 프로세스가 멈춘다는 것이고, 전체 서버도 멈춘다는 것이기 때문이다. **따라서 에러를 처리하는 방벙을 익혀두어야 한다.**

```js
setInterval(() => {
    console.log('시작');
    try {
        throw new Error('서버를 고장내주마!');
    } catch (err) {
        console.error(err);
    }
}, 1000);
```

에러는 발생하지만 try/catch로 잡을 수 있다. 이번에는 노드 자체에서 잡아주는 에러를 알아보자.
```js
const fs = require('fs');

setInterval(() => {
    fs.unlink('./abcdefg.js', (err) => {
        if (err) {
            console.error(err);
        }
    });
}, 1000);
```

존재하지 않는 파일을 삭제해 에러가 발생하지만 노드 내장 모듈의 에러는 실행 중인 프로세스를 멈추지 않는다. throw를 하는 경우 노드 프로세스가 멈춰버리기 때문에 throw를 하는 경우 **try/catch**문으로 throw한 에러를 잡아야 한다.

프로미스의 에러는 catch하지 않아도 알아서 처리된다.
```js
const fs = require('fs').promises;

setInterval(() => {
    fs.unlink('./abcdefg.js')
}, 1000);
```

또한, 간혹 예기치 못한 오류가 발생할 수 있다.
```js
process.on('uncaughtException', (err) => {
    console.error('예기치 못한 에러', err);
});

setInterval(() => {
    throw new Error('서버를 고장내주마!');
}, 1000);

setTimeout(() => {
    console.log('실행됩니다');
}, 2000);
```

**process 객체에 uncaughtException 이벤트 리스너를 달아서** 처리하지 못한 에러가 발생했을 때 이벤트 리스너가 실행되고 프로세스가 유지된다.

노드 공식 문서에서는 uncaughtException 이벤트를 최후의 수단으로 사용할 것을 명시하고 있다. uncaughtException 이벤트 발생 후 다음 동작이 제대로 작동하는지를 보증하지 않기 때문이다.

따라서 uncaughtException은 단순히 에러 내용을 기록하는 정도로 사용하고, 에러를 기록한 후 process.exit()로 프로세스를 종료하는 것이 좋다.

## 3.8.1 자주 발생하는 에러들

* node: command not found: 노드를 설치했지만 환경 변수가 제대로 설정되지 않은 경우. 환경 변수에는 노드가 설치된 경로가 포함되어야 한다.

* ReferenceError: 모듈 is not defined: 모듈을 require했는지 확인

* Error: Cannot find module 모듈명: 해당 모듈을 require했지만 설치하지 않은 경우. npmi 명령어로 설치

* Error: Can't set headers after they are sent: 요청에 대한 응답을 보낼 때 응답을 두 번 이상 보냈을 경우. 요청에 대한 응답은 한 번만 보내야 한다.

* FATAL ERROR: CALL_AND_RETRY_LAST Allocation faild - JavaScript heap out of memory: 코드를 실행할 때 메모리가 부족하여 스크립트가 정상 작동하지 않는 경우. 코드가 잘못되었을 확률이 높으므로 코드를 점검해야 한다. 만약 메모리가 부족한 경우라면 노드의 메모리를 늘릴 수 있다. `node --max-old-space-size=4096 파일명`과 같은 명령어를 사요하면 된다.

* UnhandledPromiseRejectionWarning:  Unhandled promise rejection: 프로미스 사용 시 catch 메서드를 붙이지 않으면 발생. 항상 catch를 붙여 에러가 나는 상황에 대비할 것

* EADDRINUSE 포트 번호: 해당 포트 번호에 이미 다른 프로세스가 연결되어 있다. 노드 프로세스일 수도 있고 다른 프로세스일 수도 있다. 그 프로세스를 종료하거나 다른 포트 번호를 사용해야 한다.

> * 윈도에서 프로세스 종료하기
> ```
> $ netstat -ano | findstr 포트
> $ taskkill /pid 프로세스아이디 /f
> ```
> 예를 들어 포트가 3000이고 netstat -ano | findstr 3000을 수행한 결과의 프로세스 아이디가 12345였을 경우, taskkill /pid 12345 /f를 하면 해당 프로세스가 종료된다

* EACCES 또는 EPERM: 노드가 작업을 수행하는 데 권한이 충분하지 않다. 파일/폴더 수정, 삭제, 생성 권한을 확인해 보는 것이 좋다.

* EJSONPARSE: package.json 등의 JSON 파일에 문법 오류가 있을 때 발생.

* ECONNERFUSED: 요청을 보냈으나 연결이 성립하지 않을 때 발생. 요청을 받는 서버의 주소가 올바른지, 꺼져 있지는 않은지 확인해봐야 한다.

* ETARGET: package.json에 기록한 패키지 버전이 존재하지 않을 때 발생.

* ETIMEOUT: 요청을 보냈으나 응답이 일정 시간 내에 오지 않을 때 발생. 역시 요청 받는 서버의 상태를 점검해봐야 한다.

* ENOENT: no such file or directory: 지정한 폴더나 파일이 존재하지 않는 경우.