---
layout: post
title:  "07 Mar TIL: NodeJS 쿠키와 세션, http2, cluster"
excerpt: "cookie, session, http2, cluster"
date:   2022-03-07 14:07:00 +0900
categories: 
  - Study
tags:
  - TIL
---

# 4.3 쿠키와 세션 이해하기

클라이언트에서 보내는 요청에는 누가 요청을 보내는지 모른다는 단점이 있다. 물론 요청을 보내는 IP 주소나 브라우저의 정보를 받아올 수는 있다. 하지만 여러 컴퓨터가 공통으로 IP 주소를 가지거나, 한 컴퓨터를 여러 사람이 사용할 수도 있다.

이때 사용하는 것이 로그인이며, 로그인을 구현하기 위해서는 **쿠키**와 **세션**에 대해 알고 있어야 한다. 로그인 한 이후에 새로고침을 해도 로그아웃 되지 않는 이유는 클라이언트가 서버에 누구인지 지속적으로 알려주고 있기 때문이다.

누구인지 기억하기 위해서 서버는 요청에 대한 응답을 할 때 쿠키라는 것을 같이 보낸다. **쿠키는 유효기간이 있으며 단순한 '키-값'의 쌍**이다. 서버로부터 쿠키가 오면 웹 브라우저는 쿠키를 저장해두었다가 다음에 **요청할 때마다 쿠키를 동봉**해서 보낸다. **서버는 요청에 들어있는 쿠키를 읽어서 사용자가 누구인지 파악**한다.

서버는 미리 클라이언트에 요청자를 추정할 만한 정보를 쿠키로 만들어 보내고, 그 다음부터는 클라이언트로부터 쿠키를 받아 요청자를 파악한다. 쿠키의 요청은 헤더(Cookie)에 담겨 전송된다. 브라우저는 응답의 헤더(Set-Cookie)에 따라 쿠키를 저장한다.

```js
const http = require('http');

http.createServer((req, res) => {
    console.log(req.url, req.headers.cookie);
    res.writeHead(200, { 'Set-Cookie': 'mycookie=test' });
    res.end('Hello Cookie');
})
    .listen(8083, () => {
        console.log('8083번 포트에서 서버 대기 중입니다!');
    });
```

쿠키는 name=seongtae;year=1998처럼 문자열 형식으로 존재한다. 쿠키 간에는 세미콜론(;)으로 구분된다.

createServer 메서드의 콜백에서는 req 객체에 담겨 있는 쿠키를 가져온다. 쿠키는 req.headers.cookie에 들어 있다. req.headers는 요청의 헤더를 의미한다.

응답의 헤더에 쿠키를 기록해야 하므로 res.writeHead 메서드를 사용한다. Set-Cookie는 브라우저한테 다음과 같은 값의 쿠키를 저장하라는 의미이다.

실행 결과 요청이 한 개이지만 두 개가 기록되어 있는데 /favicon.ico가 추가적으로 요청되어 { mycookie: 'test' }가 기록되어 있다. 파비콘(favicon)이란 웹사이트 탭에 보이는 이미지를 뜻하는데, 파비콘이 뭔지 HTML에서 유추할 수 없으면 서버에 파비콘 정보에 대한 요청을 보낸다. 따라서 favicon에 대한 요청이 보내진 것이다.

---

쿠키는 mycookie=test 같은 문자열이기 때문에 자바스크립트 객체 형식으로 바꾸는 함수를 사용해 객체로 전환한다.

주소가 /login으로 시작할 경우에 url과 querystring 모듈로 각각 주소와 주소에 딸려오는 query를 분석한다. 쿠키의 만료 시간도 5분으로 설정한다. 이제 302 응답 코드, 리다이렉트 주소와 함께 쿠키를 헤더에 넣는다. 브라우저는 이 응답 코드를 보고 페이지를 해당 주소로 리다이렉트한다. 헤더에는 한글을 설정할 수 없으므로 name변수를 encodeURIComponent 메서드로 인코딩한다. 또한 Set-Cookie의 값으로는 ASCII 코드만 들어가야 하므로 줄바꿈을 넣어서는 안된다.

그 외의 경우(/로 접속했을 때 등), 먼저 쿠키가 있는지 없는지를 확인한다. 쿠키가 없다면 로그인할 수 있는 페이지를 보낸다. 처음 방문한 경우에는 쿠키가 없으므로 cookie2.html이 전송되며 쿠키가 있다면 로그인한 상태로 간주하여 인사말을 보낸다.

* 쿠키명=쿠키값: 기본적인 쿠키의 값이다. mycookie=test와 같이 설정

* Expires=날짜: 만료 기한. 이 기간이 지나면 쿠키가 제거된다.

* Max-age=초: Expires와 비슷하지만 날짜 대신 초를 입력할 수 있다. Expires보다 우선한다.

* Domain=도메인명: 쿠키가 전송될 도메인을 특정할 수 있다.

* Path=URL: 쿠키가 전송될 URL을 특정할 수 있다. 기본값은 '/'이고 이 경우 모든 URL에서 쿠키를 전송할 수 있다.

* Secure: HTTPS일 경우에만 쿠키가 전송된다.

* HttpOnly: 설정 시 자바스크립트에서 쿠키에 접근할 수 없다. 쿠키 조작을 방지하기 위해 설정하는 것이 좋다.

그런데 민감한 개인 정보를 쿠키에 저장하는 것은 적절하지 않기 때문에 서버가 사용자 정보를 관리하도록 만들어보자.

서버에 사용자 정보를 저장하고 클라이언트와는 세션 아이디로만 소통한다. 세션 아이디는 꼭 쿠키를 사용해서 주고받지 않아도 된다. 하지만 많은 웹 사이트가 쿠키를 사용하는 이유는, 쿠키를 사용하는 방법이 가장 간단하기 때문이다. 세션을 위해 사용하는 쿠키를 **세션 쿠키**라고 부른다.

보통 쿠키를 메모리에 저장하지 않고 레디스(Redis)나 멤캐시드(Memcached)같은 데이터베이스에 넣어둔다.

> 서비스를 새로 만들 때마다 쿠키와 세션을 직접 구현할 수는 없다. 위의 방식 역시 세션 아이디 값이 공개되어 있어 보안 등의 문제도 있으니 조심할 것.

# 4.4 http와 http2

https 모듈은 웹 서버에 SSL 암호화를 추가한다. GET이나 POST 요청을 할 때 오가는 데이터를 암호화해서 중간에 다른 사람이 요청을 가로채더라도 내용을 확인할 수 없게 한다.

하지만 https는 아무나 사용할 수 없다. 암호화를 적용하는 만큼 그것을 인증해줄 수 있는 기관도 필요하다. 인증서는 인증 기관에서 구입해야 하며, Let's Encrypt 같은 기관에서 무료로 발급해주기도 한다.

createServer 메서드가 인수를 두 개 받는다. 두 번째 인수는 http모듈과 같이 서버 로직이고, 첫 번째 인수는 인증서에 관련된 옵션 객체이다. 인증서를 구입하면 pem이나 crt, 또는 key 확장자를 가진 파일들을 제공한다. 파일들을 fs.readFileSync 메서드로 읽어서 cert, key, ca 옵션에 알맞게 넣으면 된다. 실제 서버에서는 80 포트 대신 443 포트를 사용하면 된다.

노드의 http2 모듈은 SSL 암호화와 더불어 최신 HTTP 프로토콜인 http/2를 사용할 수 있게 한다. http/2는 요청 및 응답 방식이 기존 http/1.1보다 개선되어 훨씬 효율적으로 요청을 보낸다. http/2를 사용하면 웹의 속도도 많이 개선된다.

# 4.5 cluster

cluster 모듈은 기본적으로 싱글 프로세스로 동작하는 노드가 CPU 코어를 모두 사용할 수 있게 해주는 모듈이다. 포트를 공유하는 노드 프로세스를 여러 개 둘 수도 있으므로, 요청이 많이 들어왔을 때 병렬로 실행된 서버의 개수만큼 요청이 분산되게 할 수 있다. 즉, 서버에 무리가 덜 가게 할 수 있다.

코어를 하나 쓸 때에 비해 성능이 개선되지만, 메모리를 공유하지 못하는 등의 단점도 있다.

스레드가 아니라 프로세스라는 점이 worker_thread와 다른 점이며, 마스터 프로세스와 워커 프로세스가 있다. 마스터 프로세스는 CPU 개수만큼 워커 프로세스를 만들고 요청이 들어오면 워커 프로세스에 요청을 분배한다.

코드(code)는 process.exit의 인수로 넣어준 코드가 출력되고, 신호(signal)는 존재하는 경우 프로세스를 종료한 신호의 이름이 출력된다.

워커 프로세스가 존재하기에 CPU 코어 개수만큼 오류가 발생해도 서버가 정상 작동할 수 있다는 뜻이다. 종료된 워커를 다시 켜면 오류가 발생해도 계속 버틸 수 있다.

하지만 이렇게 오류를 처리하는 것보다 오류 자체의 원인을 찾아 해결하는 것이 중요하다. 그러나 **예기치 못한 에러로 서버가 종료되는 현상을 방지**할 수 있어 클러스터링을 적용해두는 것이 좋다.