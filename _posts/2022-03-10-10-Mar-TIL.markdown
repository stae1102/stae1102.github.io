---
layout: post
title: "10 Mar TIL: Nodejs 시퀄라이즈 쿼리 활용, CRUD 웹 생성"
excerpt: "Nodejs Utilizing sequelize query, CRUD web"
date: 2022-03-10 15:47:00 +0900
categories:
  - Study
tags:
  - TIL
---

## 7.6.3 관계 정의하기

사용자 한 명은 댓글을 여러 개 작성할 수 있다. 하지만 댓글 하나에 사용자가 여러 명일 수는 없다. 이러한 관계를 **일대다(1:N)** 관계라고 한다.

일대일 관계로는 사용자와 사용자에 대한 정보 테이블을 예로 들 수 있다. 사용자 한 명은 자신의 정보를 담고 있는 테이블과만 관계가 있다. 정보 테이블도 한 사람만을 가리킨다. 이러한 관계를 일대일(1:1) 관계라고 한다.

다대다 관계로는 게시글 테이블과 해시태그 테이블 관계를 예로 들 수 있다. 한 게시글에 여러 개의 해시태그가 달릴 수도 있고, 한 해시태그도 여러 게시글이 달릴 수 있다. 이러한 관계를 다대다(N:M) 관계라고 한다.

### 7.6.3.1 1:N

시퀄라이즈에서 1:N 관계를 hasMany라는 메서드로 표현한다. users 테이블의 로우 하나를 불러올 때 comments의 로우들도 같이 불러올 수 있다. 반대로 belongsTo 메서드도 있다. comments 테이블의 로우를 불러올 때 users 테이블의 로우를 가져온다.

다른 모델의 정보가 들어가는 테이블에 belongsTo를 사용한다. 시퀄라이즈는 모델 간 관계를 파악해서 Comment 모델에 foreignKey인 commenter 칼럼을 추가한다. User 모델의 id 컬럼을 가리키고 있다.

sourceKey의 id와 targetKey의 id 모두 User 모델의 id이다. hasMany에서는 sourceKey를 쓰고, belongsTo에서는 targetKey를 쓴다고 생각하면 된다.

foreignKey를 따로 지정하지 않는다면 이름이 모델명+기본 키인 컬럼이 모델에 생성된다.

### 7.6.3.2 1:1

hasOne 메서드를 사용한다.

예를 들어 이렇게 사용할 수 있다.

```js
db.User.hasOne(db.Info, { foreignKey: 'UserId', sourceKey: 'id' });
db.Info.belongsTo(db.User, { foreignKey: 'UserId', sourceKey: 'id' });
```

### 7.6.3.3 N:M

belongsToMany 메서드를 사용한다.

```js
db.Post.belongsToMany(db.Hashtag, { through: 'PostHashtag' });
db.Hashtag.belongsToMany(db.Post, { through: 'PostHashtag' });
```

양쪽 모델에 모두 belongsToMany 메서드를 사용한다. N:M 관계의 특성상 새로운 모델이 생성된다. through 속성에 그 이름을 적으면 된다. N:M에서는 여러 단계를 거쳐 데이터를 조회해야 하는데, 위의 경우 Post에서 PostHashtag, PostHashtag에서 Hashtag로 정보를 가져온다. 자동으로 생성된 모델들도 `db.sequelize.models.PostHashtag`를 통해 접근할 수 있다.

## 7.6.4 쿼리 알아보기

시퀄라이즈로 CRUD 작업을 하려면 먼저 시퀄라이즈 쿼리를 알아야 한다. SQL문을 자바스크립트로 생성하는 것이라 시퀄라이즈만의 방식이 있다. 쿼리는 프로미스를 반환하므로 then을 붙여 결괏값을 받을 수 있다. async/await 문법과 같이 사용할 수도 있다.

### 로우를 생성하는 쿼리

```
INSERT INTO nodejs.users (name, age, married, comment) VALUES ('zero', 24, 0, '자기소개1');
↓
const { User } = require('../models');
User.create({
  name: 'zero',
  age: 24,
  married: false,
  comment: '자기소개1',
});
```

models 모듈에서 User 모델을 불러와 **create 메서드**를 사용하면 된다. 한 가지 주의할 점은 데이터를 넣을 때 MySQL의 자료형이 아니라 시퀄라이즈 모델에 정의한 자료형 대로 넣어야 한다는 것이다. 이것이 married가 0이 아니라 false인 이유이다. 시퀄라이즈가 알아서 MySQL 자료형으로 바꾼다. 자료형이나 옵션에 부합하지 않는 데이터를 넣었을 때는 시퀄라이즈가 에러를 발생시킨다.

### 로우를 조회하는 쿼리

**findAll 메서드**를 사용한다.

```
SELECT * FROM nodejs.users;
User.findAll({});
```

다음은 users 테이블의 데이터 하나만 가져오는 SQL문이다. 앞으로 데이터를 하나만 가져올 때는 **findOne 메서드**를, 여러 개 가져올 때는 **findAll 메서드**를 사용한다고 생각하면 된다.

```
SELECT * FROM nodejs.users LIMIT 1;
User.findOne({});
```

attribute 옵션을 사용해서 원하는 컬럼만 가져올 수도 있다.
```
SELECT name, married FROM nodejs.users;
User.findAll({
  attributes: ['name', 'married'],
});
```

where 옵션이 조건을 나열하는 옵션이다.

```
SELECT name, age FROM nodejs.users WHERE married = 1 AND age > 30;
const { Op } = require('sequelize');
const { User } = require('../models');
User.findAll({
  attributes: ['name', 'age'],
  where: {
    married: true,
    age: { [Op.gt]: 30 },
  },
});
```

시퀄라이즈는 자바스크립트 객체를 사용해서 쿼리를 생성해야 하므로 Op.gt 같은 특수한 연산자들이 사용된다. 

Op.gt(초과), Op.gte(이상), Op.lt(미만), Op.lte(이하), Op.ne(같지 않음), Op.or(또는), Op.in(배열 요소 중 하나), Op.notIn(배열 요소와 모두 다름) 등이 있다.

```
SELECT id, name FROM users WHERE married = 0 OR age > 30;
const { Op } = require('sequelize');
const { User } = require('../models');
User.findAll({
  attibutes: ['id', 'name'],
  where: {
    [Op.or]: [{ marred: false }, { age: { [Op.gt]: 30 } }],
  },
});
```

시퀄라이즈를 order 옵션을 통해 정렬할 수도 있다. 배열 안에 배열이 있다는 점에 주의해야 한다. 정렬은 컬럼 하나로 하는 것이 아니라 여러 개로 할 수 있기 때문이다.

```
SELECT id, name FROM users ORDER BY age DESC;
User.findAll({
  attributes: ['id', 'name'],
  order: [['age', 'DESC']],
});
```

조회할 로우 개수를 findAll 대신 findOne 메서드를 사용해도 되지만, 다음과 같이 limit 옵션으로 할 수도 있다.
```
SELECT id, name FROM users ORDER BY age DESC LIMIT 1;
User.findAll({
  attributes: ['id', 'name'],
  order: [['age', 'DESC']],
  limit: 1,
})
```
OFFSET도 역시 offset 속성으로 구현할 수 있다.
```
SELECT id, name FROM users ORDER BY age DESC LIMIT 1 OFFSET 1;
User.findAll({
  attributes: ['id', 'name'],
  order: ['age', 'DESC'],
  limit: 1,
  offset: 1,
});
```

### 로우를 수정하는 쿼리

```
UPDATE nodejs.users SET comment = '바꿀 내용' WHERE id = 2;
User.update({
  comment: '바꿀 내용',
}, {
  where: { id: 2 },
});
```

### 로우를 삭제하는 쿼리

```
DELETE FROM nodejs.users WHERE id = 2;
User.destroy({
  where: { id:2 },
});
```
destroy 메서드로 삭제하고 where 옵션에 조건을 적는다.

### 7.6.4.1 관계 커리

findOne이나 findAll 메서드를 호출할 때 프로미스의 결과로 모델을 반환한다(findAll 은 모두 찾는 것이므로 모델의 배열을 반환한다).

const user = await User.findOne({});
console.log(user.nick); 사용자 닉네임

User 모델의 정보에도 바로 접근할 수 있지만 더 편리한 점은 관계 쿼리를 지원한다는 것이다. MySQL로 따지면 JOIN 기능이다. **include** 속성을 사용한다.

```js
const user = await User.findOne({
  include: [{
    model: Comment,
  }]
});
console.log(user.Comments); // 사용자 댓글
```

**어떤 모델과 관계가 있는지를 include 배열에 넣어주면 된다.** 배열인 이유는 다양한 모델과 관계가 있을 수 있기 때문이다. 댓글은 여러 개일 수 있으므로(hasMany) user.Comments로 접근 가능하다. 또는 다음과 같이 댓글에 접근할 수도 있다.

```js
const user = await User.findOne({});
const comments = await user.getComments();
console.log(comments); // 사용자 댓글
```

관계를 설정했다면 getComments(조회), setComments(수정), addComment(하나 생성), addComments(여러 개 생성), removeComments(삭제) 메서드를 지원한다. **동사 뒤에 모델의 이름이 붙는 식이다.**

동사 뒤의 모델 이름을 바꾸고 싶다면 관계 설정 시 as 옵션을 사용할 수 있다.

```js
// 관계를 설정할 때 as로 등록
db.User.hasMany(db.Comment, { foreignKey: 'commenter', sourceKey: 'id', as: 'Answers'});
// 쿼리할 때는
const user = await User.findOne({});
const comments = await user.getAnswers();
console.log(comments); // 사용자 댓글
```

as를 설정하면 include 시 추가되는 댓글 객체도 user.Answer로 바뀐다.

include나 관계 쿼리 메서드에도 where나 attributes 같은 옵션을 사용할 수 있다.

```js
const user = await User.findOne({
  include: [{
    model: Comment,
    where: {
      id: 1,
    },
    attributes: ['id'],
  }]
});
// 또는
const comments = await user.getComments({
  where: {
    id: 1,
  },
  attributes: ['id'],
});
```

댓글을 가져올 때는 id가 1인 댓글만 가져오고, 컬럼도 id 컬럼만 가져오도록 하고 있다.

수정, 생성, 삭제 때는 조금 다른 점이 있다.

```js
const user = await User.findOne({});
const comment = await Comment.create();
await user.addComment(comment);
// 또는
await user.addComment(comment.id);
```

여러 개를 추가할 때는 배열로 추가할 수 있다.

```js
const user = await User.findOne({});
const comment1 = await Comment.create();
const comment2 = await Comment.create();
await user.addComment([comment1, comment2]);
```
관계 쿼리 메서드의 인수로 추가할 댓글 모델을 넣거나 댓글의 아이디를 넣으면 된다. 수정이나 삭제도 마찬가지이다.

### 7.6.4.2 SQL 쿼리하기

만약 시퀄라이즈의 쿼리를 사용하기 싫거나 어렵다면 직접 SQL문을 통해 쿼리를 할 수도 있다.

```js
const [result, metadata] = await sequelize.query('SELECT * FROM comments');
console.log(result);
```

## 7.6.5 쿼리 수행하기

쿼리로 CRUD 작업을 수행합니다. GET /로 접속했을 때의 라우터는 User.findAll 메서드로 모든 사용자를 찾은 후, sequelize.html을 렌더링할 때 결괏값인 users를 넣는다.

시퀄라이즈는 프로미스를 기본적으로 지원하므로 async/await과 try/catch문을 사용해서 각각 조회 성공 시와 실패 시의 정보를 얻을 수 있다. 이렇게 미리 데이터베이스에서 데이터를 조회한 후 템플릿 렌더링에 사용할 수 있다.

---

GET /users와 POST /users 주소로 요청이 들어올 때의 라우터이다. 각각 사용자를 조회하는 요청과 사용자를 등록하는 요청을 처리한다. GET /에서도 사용자 데이터를 조회했지만, GET /users에서는 데이터를 JSON 형식으로 반환한다는 거에 차이가 있다.

GET /users/:id/comments 라우터에는 findAll 메서드에 옵션이 추가되어 있다. req.params.id로 값을 가져올 수 있다 GET /users/1/comments라면 사용자 id가 1인 댓글을 불러온다. 조회된 댓글 객체에는 include로 넣어준 사용자 정보도 들어 있으므로 작성자의 이름이나 나이 등을 조회할 수 있다.

---

댓글에 관련된 CRUD 작업을 하는 라우터이다. POST /comments, PATCH /comments/:id, DELETE /comments/:id를 등록하였다.

* POST /comments 라우터는 댓글을 생성하는 라우터이다. commenter 속성에 사용자 아이디를 넣어 사용자와 댓글을 연결한다.

* PATCH /comments/:id와 DELETE /comments/:id 라우터는 각각 댓글을 수정, 삭제하는 라우터이다. 수정과 삭제에는 각각 update와 destroy 메서드를 사용한다.