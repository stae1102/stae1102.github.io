---
layout: post
title: "백준: 2293 동전1"
excerpt: "Python, DP"
date: 2022-03-15 23:43:00 +0900
categories:
  - Baekjoon
tags:
  - DP
---

# 문제

n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.

# 입력

첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.

# 출력

첫째 줄에 경우의 수를 출력한다. 경우의 수는 $2^{31}$보다 작다.

# 문제 풀이

## A. 아이디어

모든 가능성을 체크하는데, 이전에 구했던 것이 도움이 된다. 예를 들어 5원의 가치의 경우의 수를 구할 때, 1원, 2원 3원이 있으면, 2원의 경우에 3원을 더하면 5원이 되고, 3원으 경우에 2원을 더하면 5원이 된다.

이것을 또 세세히 나누면 2원은 1원에 1원을 더해야 2원이 된다. 3원은 1원에 2원을 더하는 것과 2원에 1원을 더하는 것이 된다.

이것을 생각해보면 2원의 경우의 수를 구할 때는 1원의 경우의 수에 1원의 경우의 수를 더한 것이 2원의 경우가 되고, 3원은 1원에 2원을 더한 것과 2원의 경우의 수에 1원의 경우의 수를 더한 것이 된다.

솔직히 쓴 거 보니까 더 복잡하게 보인다.

이것을 도식으로 보자면,

* 1원을 더한다고 했을 때,

1 // **1** = 1  
1 // **2** = 1 + 1(1원에서의 1에 1을 더한 것)  
1 // **3** = 1 + 1 + 1(2원에서의 1 + 1에 1을 더한 것)  
1 // **4** = 1 + 1 + 1 + 1(3원에서의 1 + 1 + 1에 1을 더한 것)  

* 2원을 더한다고 했을 때, 1원은 2원으로 표현할 수 없으므로 2원부터 시작

1 // **1** = 1  
2 // **2** = 1 + 1, 2  
2 // **3** = 1 + 1 + 1, 1 + 2(1원에서의 1에 2를 더한 것)  
3 // **4** = 1 + 1 + 1 + 1, 1 + 1 + 2(2원에서의 1 + 1에 2를 더한 것), 2 + 2(2원에서의 2에 2를 더한 것)

* 3원을 더한다고 했을 때, 2원은 3원으로 표현할 수 없으므로 3원부터 시작

1 // **1** = 1  
2 // **2** = 1 + 1, 2  
3 // **3** = 1 + 1 + 1, 1 + 2, 3  
4 // **4** = 1 + 1 + 1, 1 + 1 + 2, 2 + 2, 1 + 3(1원에서의 1에 3을 더한 것)  
5 // **5** = 1 + 1 + 1 + 1 + 1, 1 + 1 + 1 + 2, 1 + 2 + 2, 1 + 1 + 3(2원에서의 1 + 1에 3을 더한 것), 2 + 3(2원에서의 2에 3을 더한 것)

이런 식의 로직을 따른다.

즉, 점화식을 세우자면 매 코인들이 들어올 때마다

`dp[idx] += dp[idx - coin]`를 계산하면 된다.

## B. 코드 분석

### 전체 코드

```python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())

coins = [int(input()) for _ in range(n)]

dp = [0] * (k + 1)
dp[0] = 1

def plus_coin(idx, coin):
    while idx <= k:
        dp[idx] += dp[idx-coin]
        idx += 1
    return

for coin in coins:
    plus_coin(coin, coin)

print(dp[k])
```

### B - 1. 준비

```py
import sys
input = sys.stdin.readline

n, k = map(int, input().split())

coins = [int(input()) for _ in range(n)]

dp = [0] * (k + 1)
dp[0] = 1
```

sys 모듈을 불러오고 n과 k로 입력을 받는다.

coins는 문제에서 사용할 코인들을 저장한다.

dp 테이블은 1차원 리스트로 구현하고, dp[i - 1] 이런 식으로 시작하기 때문에 dp[0]에 1을 먼저 넣어준다. 예를 들어 2원의 경우를 구한다고 할 때, dp[2] += d[0]인데, 2원은 0 + 2이기 때문이다.

### B - 2. 함수 설정 및 풀이

```py
def plus_coin(idx, coin):
    while idx <= k:
        dp[idx] += dp[idx-coin]
        idx += 1
    return

for coin in coins:
    plus_coin(coin, coin)
```
매 for문 마다 갱신해줘야 하기 때문에 def로 함수를 새로 정의했다.

plus_coin의 첫 번째 매개변수인 idx는 1씩 증가하면서 이전 코인에서의 값을 불러온다. 예를 들어 동전이 2원일 때, 3원은 1원에서 불러오고, 4원은 2원에서 불러오고, 5원은 3원에서 불러오는 식이다.

그렇게 해서 다 구해서 인덱스가 벗어나게 되면 리턴으로 함수를 탈출한다.

```py
print(dp[k])
```

이후 dp 테이블이 다 정리됐으면 추출한다.

# 총평

새로운 방식의 DP 접근이어서 신선했다. 물론 이런 로직 문제가 이미 굉장히 많다고 들었지만, 나는 처음이었다. dp 테이블이 그냥 이전 테이블을 한 번만 참고하는 것이 아니라, 계속해서 참고하는 부분이 신선하게 다가왔고 나중에 이런 문제가 나왔을 때 유용하게 응용할 수 있을 것 같다.

![2293](https://user-images.githubusercontent.com/83271772/158409337-61368b16-d847-42b4-98e4-80319ec6dace.PNG)