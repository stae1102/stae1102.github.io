---
layout: post
title:  "27 Feb TIL: Git 5가지 기능, js 배열, Node.js 개념"
excerpt: "Git-amend, cherry-pick, reset, revert, stash & js Array & Node.js basic concept"
date:   2022-02-27 23:41:00 +0900
categories: 
  - Study
tags:
  - TIL
---

### 4-3-3. 묵은 커밋을 방금 한 커밋처럼: 리베이스(Rebase)

* 풀 리퀘스트를 보냈을 때 충돌이 난다면 두 가지 방법을 택할 수 있습니다. 첫 번째는 현재 커밋과 병합하고 싶은 커밋을 미리 내 브랜치에서 병합 커밋을 만들고 이를 풀 리퀘스트로 보내는 방법입니다.

* 충돌이 발생하는 부분을 해결하고 만든 병합 커밋을 올리면 충돌이 나지는 않지만, 풀 리퀘스트에서 불필요한 커밋의 이력이 생기게 됩니다. 이를 위해서 묵은 커밋을 방금 한 커밋처럼 이력을 조작하는 것입니다.

* 원본저장소의 옛 커밋을 base로 원격저장소가 커밋을 진행하였고, 원본저장소는 base에서 커밋을 또 올렸을 때, 커밋의 베이스를 원본저장소의 새 커밋으로 옮기면 빨리감기 머지가 가능한 상태일 것입니다.

* 이렇게 커밋의 베이스를 떼어내 다른 곳으로 붙이는 것이 리베이스(rebase)입니다. 예전에 커밋을 기준으로 만들었던 브랜치를, 최신 코드를 기준으로 만든 것처럼 조작하는 것입니다.

> 소스트리에서 재배치를 누른 후 충돌이 난 부분을 수정한 이후 재배치를 계속하여 리베이스 한다. 이때, 푸시를 하게 되면 히스토리를 강제로 조작하는 것이기 때문에 다른 개발자가 이 변경 사항을 사용하지 있지 않아야 한다.

# Chapter 5. 실무 사례와 함께 Git 배우기

## 5-1. 실습을 위한 사전 준비: 새로운 원격저장소 만들기

* GitHub에서 New repository를 만들고 소스트리에서 클론

## 5-2. amend: 수정 못한 파일이 있어요, 방금 만든 커밋에 추가하고 싶어요.

### 5-2-1. amend로 마지막 커밋 수정하기

* 파일을 생성하여 커밋을 한 이후, 파일의 수정을 깜빡하여 다시 수정을 하고 재커밋을 올리는 것 보다 커밋을 수정하는 편이 더 깔끔할 것입니다.

* 소스트리에서 수정 사항을 스테이지에 올리고 커밋 옵션에서 마지막 커밋 정정 옵션을 선택한 채 커밋을 올리면 됩니다.

### 5-2-2. amend로 마지막 커밋 메시지를 수정하고 원격저장소 브랜치에 강제 푸시하기

* 소스트리에서 마지막 커밋 정정으로 다시 커밋을 수정하고, 푸시할 때는 [강제 푸시]로 로컬저장소의 변경사항을 원격저장소에 강제로 덮어씌웁니다.

## 5-3. cherry-pick: 저 커밋 하나만 떼서 지금 브랜치에 붙이고 싶어요.

### 5-3-1. cherry-pick: 다른 브랜치의 커밋 하나만 내 브랜치에 반영하기

* 다른 브랜치에서 내 브랜치로 추가하면 좋을 커밋을 받기 위해 병합할 필요 없이 다른 브랜치의 커밋을 체리픽하여 내 브랜치의 최신 커밋으로 불러올 수 있습니다.

## 5-4. reset: 옛날 커밋으로 브랜치를 되돌리고 싶어요

### 5-4-1. Soft/Mixed reset: 모든 기억을 남기면서 브랜치를 되돌리기

* 원하는 시점의 커밋에 마우스 우클릭하여 [이 커밋까지 현재 브랜치를 초기화]를 선택합니다. 모드는 [Soft], [Mixed], [Hard] 모드 중 하나를 선택해야 합니다.

* Soft 모드는 변경사항을 커밋하기 전 상태로 되돌리며, 변경 사항을 스테이지 위로 둬서 다시 당장 커밋할 수 있고, Mixed모드는 스테이지 아래로 두어서 어떤 것을 다시 스테이지 위로 Add 할지 선택할 수 있습니다.

### 5-4-2. Hard reset: 모든 기억을 지우며 브랜치를 되돌리기

* Hard 모드는 이전의 커밋은 모두 지우는 것입니다. 원격브랜치에도 적용하기 위해서는 히스토리를 조작하는 것이기 때문에 강제푸시로 푸시해줍니다.

## 5-5. revert: 이 커밋의 변경사항을 되돌리고 싶어요

* 변경사항을 되돌리기 위해 되돌리고 싶은 커밋에서 [커밋 되돌리기]를 선택합니다.

## 5-6. stash: 변경 사항을 잠시 다른 곳에 저장하고 싶어요, 커밋은 안 만들래요

현재 브랜치에서 개발하고 있는데 급히 고쳐야 하는 버그가 발생했습니다. 그런데 현재 브랜치에는 아직 커밋하지 않은 변경사항이 있습니다. 하지만 커밋하기에는 애매한 파일들입니다. 이때 이 변경사항을 잠시 보관해두었다가 다시 사용하는 것이 스태시(stash)입니다.

---


# Chapter 7. 배열을 쉽게 다루자! Array 객체

## 7-1. Array 객체란?

### Array 객체로 배열 만들기

Array 객체를 사용해 인스턴스를 만듭니다.

```js
var myArray = new Array(); // Array 객체의 인스턴스를 만듭니다.
```

초깃갑이 있는 배열이라면 리터럴을 사용한 방법으로 배열을 만들 수도 있고 Array 객체를 사용해서 만들 수도 있습니다.

```js
var numbers = ["one", "two", "three", "four"];   // 리터럴을 사용한 배열
var numbers = new Array("one", "two", "three", "four");   // Array 객체를 사용한 배열
```

### 배열에서 for문 사용하기

배열에 있는 값을 전부 확인하기 위해서는 for문을 처음 요소부터 끝 요소까지 반복합니다. 배열의 원소 개수를 확인하려면 Array 객체의 length 속성을 사용합니다.

```js
var seasons = ["봄", "여름", "가을", "겨울"];
seasons.length
```

Array의 모든 요소를 가져오기 for문과 length 속성을 이용합니다.

```js
for (var i = 0; i < seasons.length; i++) {
    console.log(seasons[i]);
}
```

## 7-2. Array 객체의 함수 알아보기

### 둘 이상의 배열을 연결하는 concat() 함수

```js
var nums = ["1", "2", "3"];
var chars = ["a", "b", "c", "d"];
nums.concat(chars)
(7) ['1', '2', '3', 'a', 'b', 'c', 'd']
```

concat() 함수는 새로운 배열을 만들기 때문에 기존의 배열에는 영향을 주지 않습니다.

### 배열 요소를 연결하는 join() 함수

`join()` 함수는 배열 요소를 연결하는 함수입니다. 배열 요소를 연결할 때는 각 요소 사이에 넣을 구분 기호가 필요한데, 지정하지 않으면 콤마(,)로 구분하며, join() 괄호에 값을 직접 넣어 구분할 수도 있습니다.

```js
nums.join()
"1,2,3"
nums.join("-")
"1-2-3"
```

### 새로운 요소를 추가하는 `push()` 함수와 `unshift()` 함수

배열의 맨 끝에 요소를 추가하려면 `push()` 함수를 사용하고, 배열의 맨 앞에 추가하려면 unshift 함수를 사용합니다.

```js
nums.push("4", "5")
5
nums
(5) ["1", "2", "3", "4", "5"]
```

```js
nums.unshift("0")
6
nums
(6) ["0", "1", "2", "3", "4", "5"]
```

### 배열에서 요소를 추출하는 `pop()` 함수와 `shift()` 함수

Array 객체에서 맨 뒤에 있는 요소를 추출할 때는 `pop()` 함수를, 맨 앞에 있는 요소를 추출할 때는 `shift()` 함수를 사용합니다.

```js
var study = ["html", "css", "javascript"];
study.pop()
'javascript'
study
(2) ['html', 'css']
```

```js
var js = ["es6+", "node", "react", "angular", "vue"];
js.shift()
'es6+'
js
(4) ['node', 'react', 'angular', 'vue']
```

### 원하는 위치의 요소를 삭제하거나 추가하는 `splice()` 함수

앞서 살펴본 `push()` 함수와 `unshift()` 함수는 배열의 맨 앞 또는 맨 뒤에 요소를 추가하는 함수이고, `pop()` 함수와 `shift()` 함수는 배열의 맨 앞 또는 맨 뒤의 요소를 추출하는 함수였습니다.  
  
만약 배열의 중간 부분에 요소를 추가하거나 삭제하고 싶거나, 한꺼번에 2개 이상의 요소를 추가하거나 삭제하기 위해서 사용하는 함수가 `splice()`함수입니다.
  
#### 인수가 1개일 경우
  
괄호 안의 인수는 그 배열의 인덱스 값을 가리킵니다.  
  
splice() 함수는 인수의 인덱스부터 끝에 있는 요소까지 모두 삭제합니다.

```js
var numbers = [0, 1, 2, 3, 4, 5]
numbers.splice(2)
(4) [2, 3, 4, 5]
numbers
(2) [0, 1]
```

#### 인수가 2개일 경우

splice() 함수에 인수가 2개일 경우 첫 번째 인수는 인덱스 값이고 두 번째 인수는 삭제할 개수입니다.

```js
var study = ["html", "css", "web", "jquery"]
study.splice(2, 1)
▶ ['web']
study
▶ (3) ['html', 'css', 'jquery']
```

#### 인수가 3개 이상일 경우

세 번째 인수부터는 앞서 삭제한 위치에 새로 추가할 요소를 지정합니다.

```js
study.splice(2, 1, "js")
▶ ["jquery"]
study
▶ (3) ['html', 'css', 'js']
```

앞선 study 배열의 "jquery"가 없어지고 그 자리에 "js"가 추가되었습니다.  
  
기존 배열의 요소를 삭제하지 않고 새로운 요소를 추가하고 싶다면 삭제할 개수를 지정하는 두 번째 인수에 0을 넣으면 됩니다.

```js
study.splice(2, 0, "jquery")
▶ []
study
▶ (4) ['html', 'css', 'jquery', 'js']
```

여러 개의 요소를 추가하고 싶을 때는 추가하고 싶은 요소를 세 번째 인수부터 차례대로 나열하면 됩니다.

```js
var chars = ["a", "e", "f"]
chars.splice(1, 0, "b", "c", "d")
▶ []
chars
▶ (6) ['a', 'b', 'c', 'd', 'e', 'f']
```

### 원하는 위치의 요소들을 추출하는 `slice()` 함수

`slice()`함수는 파이썬의 슬라이스처럼 원하는 배열의 일부분을 꺼낼 수 있는 함수입니다. slice의 인수가 1개일 때는 인수 인덱스부터 맨 끝까지 요소를 꺼내오며, 인수가 2개일 때는 첫 번째 인수 인덱스부터 두 번째 인수 인덱스 직전까지 꺼내옵니다.

```js
var colors = ["red", "green", "blue", "white", "black"]
colors.slice(2)
▶ (3) ['blue', 'white', 'black']
colors
▶ (5) ['red', 'green', 'blue', 'white', 'black']
```

```js
var colors2 = colors.slice(1, 4)
colors2
▶ (3) ['green', 'blue', 'white']
colors
▶ (5) ['red', 'green', 'blue', 'white', 'black']
```

---

# 1장. 노드 시작하기

런타임, 이벤트 기반, 논 블로킹 I/O, 싱글 스레드 모델 등 핵심 개념을 다룹니다.

## 1.1 핵심 개념 이해하기

### 1.1.1 서버

* 서버는 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램을 말합니다. 클라이언트란 요청을 보내는 주체로 브라우저일 수도 데스크톱 프로그램일 수도 있고, 모바일 앱일 수도 있고, 다른 서버에 요청을 보내는 서버일 수도 있습니다.
  
예를 들어 길벗출판사의 웹 사이트를 방문한다고 생각해봅시다. 주소창에 길벗출판사의 웹사이트 주소를 입력 **(요청)** 하면 브라우저는 그 주소에 해당하는 길벗출판사의 컴퓨터 위치를 파악합니다. 그리고 그 컴퓨터로부터 길벗출판사의 웹 사이트 페이지를 받아와서 요청자의 브라우저(클라이언트)에 띄웁니다 **(응답)**. 이런 일을 하는 컴퓨터가 바로 서버입니다.  
  
모바일 앱을 설치하는 경우를 생각해봅시다. 구글 플레이 스토어나 애플 앱스토어에서 원하는 앱을 고른 후 설치 버튼을 누르면 **(요청)** 내려받기 **(응답)** 가 시작됩니다. 앱 설치 파일은 이미 어딘가에 저장되어 있으므로 여러분이 그곳에서 데이터를 받아와 모바일 기기에 설치할 수 있는 것입니다. 플레이 스토어와 애플 스토어는 클라이언트 역할을 하는 것이고요.

* 데이터를 어딘가에 저장하고, 그 어딘가에 클라이언트로 데이터를 받아와야 합니다. 이곳이 바로 서버입니다.

* 서버는 다른 서버에도 요청을 보낼 수도 있는데 이때는 서버가 클라이언트 역할을 합니다.

* 노드는 자바스크립트 프로그램이 서버로서 기능하기 위한 도구를 제공하므로 서버 역할을 수행할 수 있습니다.

### 1.1.2 자바스크립트 런타임

* 노드는 자바스크립트 런타임입니다. 런타임은 **특정 언어로 만든 프로그램들을 실행할 수 있는 환경**을 뜻합니다. 따라서 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있습니다. 

<table border="1">
    <tr>
        <td colspan = "2" align='center'>Node.js Core Library</td>
    </tr>
    <tr>
        <td colspan = "2" align='center'>Node.js Bindings</td>
    </tr>
    <tr>
        <td align='center'>V8</td>
        <td align='center'>libuv</td>
    </tr>
</table>

V8: 오픈 소스 자바스크립트 엔진  
libuv: 비동기 I/O

* 노드는 V8과 더불어 libuv 라이브러리를 사용합니다. libuv 라이브러리는 노드의 특성인 **이벤트 기반, 논 블로킹 I/O 모델**을 구현하고 있습니다.

### 1.1.3 이벤트 기반

* 이벤트 기반(event-driven)이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미합니다.

이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 합니다. 이를 **이벤트 리스너(event listener)** 에 **콜백(callback)** 함수를 등록한다고 표현합니다. 

노드도 이벤트 기반 방식으로 동작하므로, 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수를 호출합니다. 발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면, 노드는 다음 이벤트가 발생할 때까지 대기합니다.  
  
이벤트 기반 모델에서는 **이벤트 루프(event loop)** 라는 개념이 등장합니다. 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단합니다.  

* 노드는 자바스크립트 코드의 맨 위부터 한 줄씩 실행합니다. 함수 호출 부분을 발견했다면 호출한 함수를 **호출 스택(call stack)** 에 넣습니다.

```js
function first() {
    second();
    console.log('첫 번째');
}
function second() {
    third();
    console.log('두 번째');
}
function third() {
    console.log('세 번째');
}
first();
```

위 과정에서 함수는 first 함수가 제일 먼저 호출되고, second 함수가 호출된 뒤, third 함수가 호출됩니다. 실행은 호출된 순서와 반대로 실행이 완료됩니다. 따라서 콘솔에는 '세 번째', '두 번째', '첫 번째' 순서로 찍히게 됩니다.  

third() -> second() -> first() -> anonymous 순서로 실행됩니다. anonymous 함수는 처음 실행 시의 **전역 컨텍스트(global context)** 를 의미합니다. 컨텍스트는 함수가 호출되었을 때 생성되는 환경을 의미합니다.  

다음 코드도 알아보겠습니다.

```js
function run() {
    console.log('3초 후 실행');
}
undefined
console.log('시작');
setTimeout(run, 3000);
console.log('끝');
```
결과는 다음과 같습니다.
```
시작
끝
3초 후 실행
```
이는 setTimeout 함수의 콜백인 run이 호출 스택에 언제 들어가는지 파악해야 합니다. 이를 파악하기 위해서는 이벤트 루프, 태스크 큐(task queue), 백그라운드(background)를 알아야 합니다.

* 이벤트 루프: 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당합니다. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(loop)라고 합니다.

* 백그라운드: setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 공간입니다. 자바스크립트가 아닌 다른 언어로 작성된 프로그램이라고 봐도 됩니다. 여러 작업이 동시에 실행될 수 있습니다.

* 태스크 큐: 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보냅니다. 정해진 순서대로 콜백들이 줄을 서 있으므로 콜백 큐라고도 부릅니다. 콜백들은 보통 완료된 순서대로 줄을 서 있지만 특정한 경우에는 순서가 바뀌기도 합니다.

먼저 전역 컨텍스트인 anonymous가 호출 스택에 들어갑니다. 그 뒤 setTimeout이 호출 스택에 들어갑니다.  

호출 스택에 들어간 순서와 반대로 실행되므로, setTimeout이 먼저 실행됩니다. setTimeout이 실행되면 타이머와 함께 run 콜백을 백그라운드로 보내고, setTimeout은 호출 스택에서 빠집니다. 그 다음으로 anonymous가 호출 스택에서 빠집니다. 백그라운드에서는 3초를 센 후 run 함수를 태스크 큐로 보냅니다. 3초를 세었다는 것은 백그라운드에 맡겨진 작업이 완료된 것으로 이해해도 됩니다.  

태스크 큐는 하나의 큐처럼 보이지만, 여러 개의 큐로 이루어져 있습니다. 이벤트 루프는 정해진 규칙에 따라 콜백 함수들을 호출 스택으로 부릅니다.  

이벤트 루프는 호출 스택이 비어 있으면 태스크 큐에서 함수를 하나씩 가져와 호출 스택에 넣고 실행합니다.  

이벤트 루프가 run 콜백을 태스크 큐에서 꺼내 호출 스택으로 올렸습니다. 호출 스택으로 올려진 run은 실행되고, 실행 완료 후 호출 스택에서 비워집니다. 이벤트 루프는 태스크 큐에 콜백 함수가 들어올 때까지 계속 대기합니다.  

만약 호출 스택에 함수들이 너무 많이 들어 있으면 3초가 지난 후에도 run 함수가 실행되지 않을 수 있습니다. 이벤트 루프는 호출 스택이 비어있을 때만 태스크 큐에서 있는 함수를 호출 스택으로 가져오기 때문입니다. 이때문에 setTimeout의 시간이 정확하지 않을 수도 있습니다.

### 1.1.4 논 블로킹 I/O

이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있습니다. 작업에는 두 가지 종류가 있는데, **동시에 실행될 수 있는 작업**과 **동시에 실행될 수 없는 작업**입니다. 기본적으로 여러분이 작성한 자바스크립트 코드는 동시에 실행될 수 없습니다. 하지만 자바스크립트상에서 돌아가는 것이 아닌 I/O 작업 같은 것은 동시에 처리될 수 있습니다.  

I/O는 **입력(Input)/출력(Output)** 을 의미합니다. 파일 시스템 접근(파일 읽기, 파일 쓰기, 폴더 만들기 등)이나 네트워크를 통한 요청 같은 작업이 I/O의 일종입니다. 이러한 작업을 할 때 노드는 논 블로킹 방식으로 처리하는 방법을 제공합니다. **논 블로킹**이란 **이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 뜻합니다**. 반대로 **블로킹**은 이전 작업이 끝나야만 다음 작업을 수행하는 것을 의미합니다.  

* 노드는 I/O 작업을 백그라운드로 넘겨 동시에 처리하곤 합니다. 따라서 동시에 처리할 수 있는 작업들은 최대한 묶어서 백그라운드로 넘겨야 시간을 절약할 수 있습니다.

동시에 처리할 수 있는 I/O 작업이라도 논 블로킹 방식으로 코딩하지 않으면 의미가 퇴색되므로 논 블로킹 방식으로 코딩하는 습관을 들여야 합니다.  

다음은 블로킹 방식의 코드입니다.

```js
function longRunningTask() {
    // 오래 걸리는 작업
    console.log('작업 끝');
}

console.log('시작');
longRunningTask();
console.log('다음 작업');
```

이 함수가 블로킹 방식으로 I/O 작업을 한다고 할 때, longRunningTask를 완료하기 전까지 이어지는 작업이 호출되지 않습니다.  

이번에는 setTimeout을 사용해서 코드를 바꿔보겠습니다.

```js
function longRunningTask() {
    // 오래 걸리는 작업
    console.log('작업 끝');
}

console.log('시작');
setTimeout(longRunningTask, 0);
console.log('다음 작업');
```
결과는 '다음 작업'이 먼저 출력된 후 '작업 끝'이 출력됩니다.  

setTimeout(콜백, 0)은 코드를 논 블로킹으로 만들기 위해 사용하는 기법 중 하나입니다. 이벤트 루프로 인해 setTimeout의 콜백 함수인 longRunningTask가 태스크 큐로 보내지므로 순서대로 실행되지 않는다는 것을 알 수 있습니다. 다음 작업이 먼저 실행된 후, 오래 걸리는 작업이 완료됩니다.  

다만, 아무리 논 블로킹 방식으로 코드를 작성하더라도 코드가 전부 여러분이 작성한 것이라면 전체 소요 시간이 짧아지지는 않습니다. 여러분의 코드는 서로 동시에 실행되지 않기 때문입니다. 단순히 실행 순서만 바뀔 뿐입니다.  

그렇다고 I/O 작업이 없다고 해서 논 블로킹이 의미가 없는 것은 아닙니다. **오래 걸리는 작업을 처리해야 하는 경우, 논 블로킹을 통해 실행 순서를 바꿔줌으로써 그 작업 때문에 간단한 작업들이 대기하는 상황을 막을 수 있다는 점에서 의의가 있습니다.** 또한, **논 블로킹**과 **동시**가 같은 의미가 아니라는 것도 알아두세요. **동시성**은 **동시 처리가 가능한 작업을 논 블로킹 처리해야 얻을 수 있습니다.**  

* 노드에서는 동기와 비동기라는 개념도 있는데, 일단 동기와 블로킹이 유사하고 비동기와 논 블로킹이 유사하다고만 알아둡시다.

### 1.1.5 싱글 스레드

* **싱글 스레드**란 스레드가 하나뿐이라는 것을 의미합니다. 여러분이 작성한 자바스크립트 코드가 동시에 실행될 수 없는 이유이기도 합니다.

* 프로세스는 **운영체제에서 할당하는 작업의 단위**입니다. 노드나 웹 브라우저 같은 프로그램은 개별적인 프로세스입니다. 프로세스 간에는 메모리 등의 자원을 공유하지 않습니다.

* 스레드는 **프로세스 내에서 실행되는 흐름의 단위**입니다. 프로세스는 스레드를 여러 개 생성해 여러 작업을 동시에 처리할 수 있습니다. 스레드들은 부모 프로세스의 자원을 공유합니다. 같은 주소의 메모리에 접근 가능하므로 데이터를 공유할 수 있습니다.

노드를 실행하면 먼저 프로세스가 하나 생성됩니다. 그리고 그 프로세스에서 스레드들을 생성하는데, 이때 내부적으로 스레드를 여러 개 생성합니다. 그중에서 여러분이 직접 제어할 수 있는 스레드는 하나뿐입니다. 그래서 흔히 노드가 싱글 스레드라고 여겨지는 것입니다.  

스레드를 작업을 처리하는 일손으로 표현하기도 하는데, 하나의 스레드만 직접 조작할 수 있으므로 일손이 하나인 셈입니다. 요청이 많이 들어오면 한 번에 하나씩 요청을 처리합니다. 블로킹이 심하게 일어나는 작업을 처리하지만 않는다면 스레드 하나로도 충분합니다. 블로킹이 발생할 것같은 경우에는 논 블로킹 방법으로 대기 시간을 최대한 줄입니다.  

언뜻 보면 멀티 스레드가 더 좋아보이지만 꼭 그런 것은 아닙니다. 손님의 수가 늘어날수록 점원의 수도 늘어나고, 손님 수가 줄어들었을 때 일을 하지 않고 노는 점원이 있다는 것도 문제가 됩니다. 점원을 새로 고용하거나 해고하는데는 비용이 발생합니다.  
  
멀티 스레드가 모두 논 블로킹 방식으로 주문을 받으면 더 좋은데, 멀티 스레드 방식으로 프로그래밍하는 것은 상당히 어렵기 때문에 멀티 프로세싱으로 대신 사용합니다. I/O 요청에는 멀티 프로세싱이 더 효율적이기도 합니다.  

I/O 작업을 처리할 때는 멀티 스레딩보다 멀티 프로세싱이 효율적이므로 노드는 멀티 프로세싱을 많이 합니다.

## 1.2 서버로서의 노드

* 노드는 기본적으로 싱글 스레드, 논 블로킹 모델을 사용하므로, 노드 서버 또한 동일한 모델일 수밖에 없습니다.