---
layout: post
title:  "07 Mar TIL: NodeJS 쿠키와 세션, http2, cluster"
excerpt: "cookie, session, http2, cluster"
date:   2022-03-07 14:07:00 +0900
categories: 
  - Study
tags:
  - TIL
---

- [5.1 npm 알아보기](#51-npm-알아보기)
- [5.2 package.json으로 패키지 관리하기](#52-packagejson으로-패키지-관리하기)

# 4.3 쿠키와 세션 이해하기

클라이언트에서 보내는 요청에는 누가 요청을 보내는지 모른다는 단점이 있다. 물론 요청을 보내는 IP 주소나 브라우저의 정보를 받아올 수는 있다. 하지만 여러 컴퓨터가 공통으로 IP 주소를 가지거나, 한 컴퓨터를 여러 사람이 사용할 수도 있다.

이때 사용하는 것이 로그인이며, 로그인을 구현하기 위해서는 **쿠키**와 **세션**에 대해 알고 있어야 한다. 로그인 한 이후에 새로고침을 해도 로그아웃 되지 않는 이유는 클라이언트가 서버에 누구인지 지속적으로 알려주고 있기 때문이다.

누구인지 기억하기 위해서 서버는 요청에 대한 응답을 할 때 쿠키라는 것을 같이 보낸다. **쿠키는 유효기간이 있으며 단순한 '키-값'의 쌍**이다. 서버로부터 쿠키가 오면 웹 브라우저는 쿠키를 저장해두었다가 다음에 **요청할 때마다 쿠키를 동봉**해서 보낸다. **서버는 요청에 들어있는 쿠키를 읽어서 사용자가 누구인지 파악**한다.

서버는 미리 클라이언트에 요청자를 추정할 만한 정보를 쿠키로 만들어 보내고, 그 다음부터는 클라이언트로부터 쿠키를 받아 요청자를 파악한다. 쿠키의 요청은 헤더(Cookie)에 담겨 전송된다. 브라우저는 응답의 헤더(Set-Cookie)에 따라 쿠키를 저장한다.

```js
const http = require('http');

http.createServer((req, res) => {
    console.log(req.url, req.headers.cookie);
    res.writeHead(200, { 'Set-Cookie': 'mycookie=test' });
    res.end('Hello Cookie');
})
    .listen(8083, () => {
        console.log('8083번 포트에서 서버 대기 중입니다!');
    });
```

쿠키는 name=seongtae;year=1998처럼 문자열 형식으로 존재한다. 쿠키 간에는 세미콜론(;)으로 구분된다.

createServer 메서드의 콜백에서는 req 객체에 담겨 있는 쿠키를 가져온다. 쿠키는 req.headers.cookie에 들어 있다. req.headers는 요청의 헤더를 의미한다.

응답의 헤더에 쿠키를 기록해야 하므로 res.writeHead 메서드를 사용한다. Set-Cookie는 브라우저한테 다음과 같은 값의 쿠키를 저장하라는 의미이다.

실행 결과 요청이 한 개이지만 두 개가 기록되어 있는데 /favicon.ico가 추가적으로 요청되어 { mycookie: 'test' }가 기록되어 있다. 파비콘(favicon)이란 웹사이트 탭에 보이는 이미지를 뜻하는데, 파비콘이 뭔지 HTML에서 유추할 수 없으면 서버에 파비콘 정보에 대한 요청을 보낸다. 따라서 favicon에 대한 요청이 보내진 것이다.

---

쿠키는 mycookie=test 같은 문자열이기 때문에 자바스크립트 객체 형식으로 바꾸는 함수를 사용해 객체로 전환한다.

주소가 /login으로 시작할 경우에 url과 querystring 모듈로 각각 주소와 주소에 딸려오는 query를 분석한다. 쿠키의 만료 시간도 5분으로 설정한다. 이제 302 응답 코드, 리다이렉트 주소와 함께 쿠키를 헤더에 넣는다. 브라우저는 이 응답 코드를 보고 페이지를 해당 주소로 리다이렉트한다. 헤더에는 한글을 설정할 수 없으므로 name변수를 encodeURIComponent 메서드로 인코딩한다. 또한 Set-Cookie의 값으로는 ASCII 코드만 들어가야 하므로 줄바꿈을 넣어서는 안된다.

그 외의 경우(/로 접속했을 때 등), 먼저 쿠키가 있는지 없는지를 확인한다. 쿠키가 없다면 로그인할 수 있는 페이지를 보낸다. 처음 방문한 경우에는 쿠키가 없으므로 cookie2.html이 전송되며 쿠키가 있다면 로그인한 상태로 간주하여 인사말을 보낸다.

* 쿠키명=쿠키값: 기본적인 쿠키의 값이다. mycookie=test와 같이 설정

* Expires=날짜: 만료 기한. 이 기간이 지나면 쿠키가 제거된다.

* Max-age=초: Expires와 비슷하지만 날짜 대신 초를 입력할 수 있다. Expires보다 우선한다.

* Domain=도메인명: 쿠키가 전송될 도메인을 특정할 수 있다.

* Path=URL: 쿠키가 전송될 URL을 특정할 수 있다. 기본값은 '/'이고 이 경우 모든 URL에서 쿠키를 전송할 수 있다.

* Secure: HTTPS일 경우에만 쿠키가 전송된다.

* HttpOnly: 설정 시 자바스크립트에서 쿠키에 접근할 수 없다. 쿠키 조작을 방지하기 위해 설정하는 것이 좋다.

그런데 민감한 개인 정보를 쿠키에 저장하는 것은 적절하지 않기 때문에 서버가 사용자 정보를 관리하도록 만들어보자.

서버에 사용자 정보를 저장하고 클라이언트와는 세션 아이디로만 소통한다. 세션 아이디는 꼭 쿠키를 사용해서 주고받지 않아도 된다. 하지만 많은 웹 사이트가 쿠키를 사용하는 이유는, 쿠키를 사용하는 방법이 가장 간단하기 때문이다. 세션을 위해 사용하는 쿠키를 **세션 쿠키**라고 부른다.

보통 쿠키를 메모리에 저장하지 않고 레디스(Redis)나 멤캐시드(Memcached)같은 데이터베이스에 넣어둔다.

> 서비스를 새로 만들 때마다 쿠키와 세션을 직접 구현할 수는 없다. 위의 방식 역시 세션 아이디 값이 공개되어 있어 보안 등의 문제도 있으니 조심할 것.

# 4.4 http와 http2

https 모듈은 웹 서버에 SSL 암호화를 추가한다. GET이나 POST 요청을 할 때 오가는 데이터를 암호화해서 중간에 다른 사람이 요청을 가로채더라도 내용을 확인할 수 없게 한다.

하지만 https는 아무나 사용할 수 없다. 암호화를 적용하는 만큼 그것을 인증해줄 수 있는 기관도 필요하다. 인증서는 인증 기관에서 구입해야 하며, Let's Encrypt 같은 기관에서 무료로 발급해주기도 한다.

createServer 메서드가 인수를 두 개 받는다. 두 번째 인수는 http모듈과 같이 서버 로직이고, 첫 번째 인수는 인증서에 관련된 옵션 객체이다. 인증서를 구입하면 pem이나 crt, 또는 key 확장자를 가진 파일들을 제공한다. 파일들을 fs.readFileSync 메서드로 읽어서 cert, key, ca 옵션에 알맞게 넣으면 된다. 실제 서버에서는 80 포트 대신 443 포트를 사용하면 된다.

노드의 http2 모듈은 SSL 암호화와 더불어 최신 HTTP 프로토콜인 http/2를 사용할 수 있게 한다. http/2는 요청 및 응답 방식이 기존 http/1.1보다 개선되어 훨씬 효율적으로 요청을 보낸다. http/2를 사용하면 웹의 속도도 많이 개선된다.

# 4.5 cluster

cluster 모듈은 기본적으로 싱글 프로세스로 동작하는 노드가 CPU 코어를 모두 사용할 수 있게 해주는 모듈이다. 포트를 공유하는 노드 프로세스를 여러 개 둘 수도 있으므로, 요청이 많이 들어왔을 때 병렬로 실행된 서버의 개수만큼 요청이 분산되게 할 수 있다. 즉, 서버에 무리가 덜 가게 할 수 있다.

코어를 하나 쓸 때에 비해 성능이 개선되지만, 메모리를 공유하지 못하는 등의 단점도 있다.

스레드가 아니라 프로세스라는 점이 worker_thread와 다른 점이며, 마스터 프로세스와 워커 프로세스가 있다. 마스터 프로세스는 CPU 개수만큼 워커 프로세스를 만들고 요청이 들어오면 워커 프로세스에 요청을 분배한다.

코드(code)는 process.exit의 인수로 넣어준 코드가 출력되고, 신호(signal)는 존재하는 경우 프로세스를 종료한 신호의 이름이 출력된다.

워커 프로세스가 존재하기에 CPU 코어 개수만큼 오류가 발생해도 서버가 정상 작동할 수 있다는 뜻이다. 종료된 워커를 다시 켜면 오류가 발생해도 계속 버틸 수 있다.

하지만 이렇게 오류를 처리하는 것보다 오류 자체의 원인을 찾아 해결하는 것이 중요하다. 그러나 **예기치 못한 에러로 서버가 종료되는 현상을 방지**할 수 있어 클러스터링을 적용해두는 것이 좋다.

# 5.1 npm 알아보기

npm은 Node Package Manager의 약어로 노드 패키지 매니저이다.

# 5.2 package.json으로 패키지 관리하기

패키지는 저마다 고유한 버전이 있으며, 같은 패키지라도 버전별로 기능이 다를 수 있으므로 프로젝트를 설치할 때 패키지도 동일한 버전으로 설치하는 것이 좋다. 이때 설치한 패키지의 버전을 관리하는 파일이 package.json이다.

**따라서 노드 프로젝트를 시작하기 전에는 폴더 내부에 무조건 package.json부터 만들고 시작해야 한다.** npm은 package.json을 만드는 명령어를 제공한다.

* package name: 패키지의 이름. package.json의 name 속성에 저장된다.
* version: 패키지의 버전이다. npm의 버전은 다소 엄격하게 관리된다.
* entry point: 자바스크립트 실행 파일 진입점. 보통 마지막으로 module.exports를 하는 파일을 지정한다. package.json의 main 속성에 저장된다.
* test command: 코드를 테스트할 때 입력할 명령어를 의미한다. package.json scripts 속성 안의 test 속성에 저장된다.
* git repository: 코드를 저장해둔 깃(Git) 저장소 주소를 의미한다. package.json의 repository 속성에 저장된다.
* keywords: 키워드는 npm 공식 홈페이지에서 패키지를 쉽게 찾을 수 있도록 해준다. package.json의 keywords 속성에 저장된다.
* license: 해당 패키지의 라이선스를 넣으면 된다.

script 부분은 npm 명령어를 모아놓은 부분으로 콘솔에서 `npm run [스크립트 명령어]`를 입력하면 해당 스크립트가 실행된다. 보통 start 명령어에 `node [파일명]`을 저장해두고 `npm start`로 실행한다. start나 test 같은 스크립트는 run을 붙이지 않아도 실행된다.

패키지 설치는 `npm install [패키지 이름]`을 통해 package.json이 있는 폴더의 콘솔에서 입력하면 된다.

```
$ npm install express
```

설치한 패키지가 package.json에 기록된다.

```json
{
  "name": "npmtest",
  ...
  "license": "ISC",
  "dependencies": {
    "express": "^4.17.3"
  }
}
```

버전 앞에 ^ 표시가 붙는데 여기에는 특별한 의미가 있다.(향후 알아볼 예정)

node_modules라는 폴더가 생성된다. 그 안에 설치한 패키지들이 들어 있다. Express 외에도 다양한 패키지가 들어 있는데, 이는 Express가 의존하는 패키지들이다. 의존 관계가 복잡하게 얽혀 있기 때문에 package.json이 필요한 것이다.

package-lock.json이라는 파일도 생성되어 있는데, express 외에도 node_modules에 들어 있는 패키지들의 정확한 버전과 의존 관계가 담겨있다. mp으로 패키지를 설치, 수정, 삭제할 때마다 패키지들 간의 내부 의존 관계를 이 파일에 저장한다.

모듈을 여러 개 설치할 때는 `npm install [패키지1] [패키지2] [...]`와 같이 나열하면 된다.

```
$ npm install morgan cookie-parser express-session
```

개발용 패키지를 설치할 수도 있다. 실제 배포 시에는 사용되지 않고 개발 중에만 사용되는 패키지들이다. `npm install --save-dev [패키지] [...]`로 설치한다. --save-dev가 개발용 패키지임을 나타낸다.

새로 생긴 devDependencies 속성에서는 개발용 패키지들만 따로 관리한다.

npm에는 전역(global) 설치라는 옵션도 있다. 현재 폴더에 설치하는 것이 아니라 **npm이 설치되어 있는 폴더에 설치**하는 것이다. 이 폴더의 경로는 보통 시스템 환경 변수에 등록되어 있으므로 전역 설치한 패키지는 콘솔의 명령어로 사용할 수 있다. 대부분 명령어로 사용하기 위해 전역 설치한다.

rimraf는 리눅스나 맥의 rm -rf 명령어를 윈도에서도 사용할 수 있게 해주는 패키지이다. rm -rf는 지정한 파일이나 폴더를 지우는 명령어이다. 전역 설치했기 때문에 명령어를 콘솔에서 사용할 수 있다. package.json에는 기록되지 않는다.

rimraf로 node_modules 폴더를 삭제하더라도 package.json에 설치한 패키지 내역이 들어 있으므로 `npm install`만 하면 알아서 다시 설치된다. 즉, **언제든지 설치할 수 있으므로 보관할 필요가 없다.** 깃 같은 버전 관리 프로그램과 같이 사용할 때도 node_modules는 커밋하지 않는다. **중요한 파일은 package.json이다.**

> **npx**
> 
> 전역 설치한 패키지는 package.json에 기록되지 않아 다시 설치할 때 어려움이 따른다. 이러한 경우를 위한 명령어로 npx가 있다.
> ```
> $ npm install --save-dev rimraf
> $ npx rimraf node_modules
> ```
> 위와 같이 rimraf 모듈을 package.json의 devDependencies 속성에 기록한 후, 앞에 npx 명령어를 붙여 실행하면 된다. 이렇게 하면 패키지를 전역 설치한 것과 같은 효과(명령어로 사용 가능)를 얻을 수 있다. 패키지가 package.json에 기록되었으므로 버전 관리도 용이하다.

> **npm에 등록되지 않은 패키지**
> 
> 일부 소스는 오픈 소스가 아니거나 개발 중이므로 깃허브 등의 저장소에 보관되어 잇을 수도 있다. 그러한 패키지들도 `npm install [저장소 주소]` 명령어를 통해 설치할 수 있다.

> **명령어 줄여쓰기**
> 
> npm install 명령어는 npm i로 줄여 쓸 수 있다. --save-dev 옵션은 -D로, --global 옵션은 -g로 줄여 써도 된다.

---

# Chapter 5. 테이블과 뷰

## 5-1. 테이블 만들기

테이블: 행(row, record)과 열(column, field)로 구성된 2차원 구조

### 5-1-1. 데이터베이스와 테이블 설계하기

테이블을 만들기 위해 테이블을 설계한다. 테이블 이름, 열 이름, 데이터 형식, 기본 키를 적절히 지정하여 설계한다.

### 5-1-2. GUI 환경에서 테이블 만들기

#### 데이터 베이스 생성하기

```sql
CREATE DATABASE 데이터베이스_이름;
```

#### 테이블 생성하기

GUI 에서는 기본 키-외래 키 관계를 선택할 수 없다.

#### 데이터 입력하기

기본 키와 외래 키 관계인 열의 레이블에서 기본 키 열에 없는 데이터가 외래 키에 있으면 안 된다. **외래 키에 있는 값은 반드시 기본 키에도 있어야 한다.**

### 5-1-3. SQL로 테이블 만들기

#### 데이터베이스 생성하기

```sql
CREATE DATABASE naver_db;
```

#### 테이블 생성하기

```sql
CREATE TABLE member -- 회원 테이블
( mem_id		CHAR(8) NOT NULL PRIMARY KEY, -- 회원 아이디(PK)
  mem_name		VARCHAR(10) NOT NULL, -- 이름
  mem_number	TINYINT NOT NULL, -- 인원수
  addr			CHAR(2) NOT NULL, -- 주소(경기, 서울, 경남 식으로 2글자만 입력)
  phone1		CHAR(3) NULL, -- 연락처의 국번(02, 031, 055 등)
  phone2        CHAR(8) NULL, -- 연락처의 나머지 전화번호(하이픈 제외)
  height		TINYINT UNSIGNED NULL, -- 평균 키
  debut_date	DATE NULL -- 데뷔 일자
);
```
테이블을 기본적으로 갖춘 뒤, NOT NULL 혹은 NULL을 입력하고 PRIMARY KEY를 입력한다.

AUTO_INCREMENT로 지정한 열은 **PRIMARY KEY**나 **UNIQUE**로 꼭 지정해야 한다.

```sql
FOREIGN KEY(mem_id) REFERENCES member(mem_id)
```

FK의 기준이 되는 PK열을 REFERENCES를 통해 연결한다.

#### 데이터 입력하기

```sql
INSERT INTO member VALUES('TWC', '트와이스', 9, '서울', '02', '11111111', 167, '2015-10-19');
INSERT INTO member VALUES('BLK', '블랙핑크', 4, '경남', '055', '22222222', 163, '2016-8-8');
INSERT INTO member VALUES('WMN', '여자친구', 6, '경기', '031', '33333333', 166, '2015-1-15');
```

## 5-2. 제약조건으로 테이블을 견고하게

테이블을 만들 때 테이블의 구조에 필요한 제약조건을 설정해줘야 하는데, 앞에서 확인한 기본 키와 외래 키가 대표적인 제약조건이다.

이메일, 휴대폰 등 중복되지 않는 열에는 고유 **키(Unique)** 를 지정할 수 있다. 또한, 실수로 값을 올바르지 않게 입력하는 것을 방지하는 제약조건이 **체크(Check)** 이다. 제약조건으로 **기본값(Default)** 을 설정할 수도 있고, **NOT NULL**도 제약조건으로 설정할 수 있다

### 5-2-1. 제약조건의 기본 개념과 종류

**제약조건**은 데이터의 무결성을 지키기 위해 제한하는 조건이다. 데이터의 결함이 없는 것을 **데이터의 무결성**이라고 표현한다.

* PRIMARY KEY 제약조건

* FOREIGN KEY 제약조건
  
* UNIQUE 제약조건

* CHECK 제약조건

* DEFAULT 정의

* NULL 값 허용

### 5-2-2. 기본 키 제약조건

데이터를 구분할 수 있는 식별자를 **기본 키(Primary Key)** 라고 부른다. 기본 키에 입력되는 값은 **중복될 수 없으며, NULL 값이 입력될 수 없다.**

대부분의 테이블은 기본 키를 가져야 한다. 물론, 기본 키가 없어도 테이블 구성이 가능하지만 실무에서 사용하는 테이블에는 기본 키를 설정해야 중복된 데이터가 입력되지 않는다. 기본 키로 생성한 것은 자동으로 **클러스터형 인덱스**가 생성된다. 기본 키는 하나의 열에만 설정해야 하기 때문에 테이블의 특성을 가장 잘 반영하는 열을 선택하는 것이 좋다.

#### CREATE TABLE에서 설정하는 기본 키 제약조건

열 이름 뒤에 PRIMARY KEY를 입력하여 기본 키로 설정하면 설정한 열에 입력되는 데이터는 중복될 수 없고, 비어 있을 수도 없다.

**기본 키-외래 키 관계로 연결된 테이블은 외래 키가 설정된 테이블을 먼저 삭제해야 한다.** 기본 키 테이블이 삭제되면 외래 키 테이블에서 데이터를 알 수 없기 때문.

기본 키는 제일 마지막 행에 `PRIMARY KEY (열_이름)`을 통해 지정할 수도 있다.

#### ALTER TABLE에서 설정하는 기본 키 제약조건

제약조건을 설정하는 또 다른 방법은 이미 만들어진 테이블을 수정하는 ALTER TABLE 구문을 사용하는 것이다.

```sql
ALTER TABLE member -- 1. member를 변경
	ADD CONSTRAINT -- 2. 제약조건 추가
    PRIMARY KEY (mem_id); -- 3. mem_id 열에 기본 키 제약조건을 설정
```

> **기본 키에 이름 지정하기**
> 
> 기본 키의 이름을 직접 지어줄 수도 있다.  
> `CONSTRAINT PRIMARY KEY PK_member_mem_id (mem_id)`

### 5-2-3. 외래 키 제약조건

외래 키 제약조건은 두 테이블 사이의 관계를 연결해주고 그 결과 데이터의 무결성을 보장해주는 역할을 한다. 외래 키가 설정된 열은 꼭 다른 테이블의 기본 키와 연결된다.

기본 키가 있는 테이블을 **기준 테이블**이라고 부르며, 외래 키가 있는 구매 테이블을 **참조 테이블**이라고 부른다.

구매 테이블과 회원 테이블이 서로 기본 키-외래 키 관계일 때, 구매 테이블의 데이터는 모두 누구인지 알 수 있는 무결한 데이터가 되는 것이다.

참조 테이블이 참조하는 기준 테이블의 열은 반드시 **기본 키나 고유 키로 설정**되어 있어야 한다.

#### CREATE TABLE에서 설정하는 외래 키 제약조건

CREATE TABLE 끝에 FOREIGN KEY 키워드를 설정하는 것으로 생성한다.

`FOREIGN KEY(열_이름) REFERENCES 기준_테이블(열_이름)`이 기본 형식으로 참조할 기준 테이블의 열은 Primary Key 또는 Unique여야만 한다.(꼭 열 이름이 같을 필요는 없음)

#### ALTER TABLE에서 설정하는 외래 키 제약조건

```sql
ALTER TABLE buy -- 1. buy를 수정한다.
	ADD CONSTRAINT -- 2. 제약조건을 추가한다.
	FOREIGN KEY(mem_id) -- 3. 외래 키 제약조건을 buy 테이블의 mem_id에 설정한다.
    REFERENCES member(mem_id); -- 4. 참조할 기준 테이블은 member 테이블의 mem_id 열이다.
```

#### 기준 테이블의 열이 변경될 경우

기준 테이블 열의 데이터를 변경하고자 할 때 오류가 발생한다. 열 이름이 변경되면 참조 테이블의 데이터에 문제가 발생하기 때문이다(만약 참조 테이블에 기준 테이블 열 데이터가 없다면 변경 가능). 같은 이유로 삭제도 불가능하다. 기준 테이블의 열 이름이 변경될 때 참조 테이블의 열 이름이 자동으로 변경되는 것이 더 효율적일 것이다.

이를 위해 **`ON UPDATE CASCADE`** 와 **`ON DELETE CASCADE`** 문을 통해 자동으로 변경되도록 할 수 있다.

```sql
ALTER TABLE buy
  ADD CONSTRAINT
  FOREIGN KEY(mem_id) REFERENCES member(mem_id)
  ON UPDATE CASCADE
  ON DELETE CASCADE
```
ALTER TABLE에서 입력하고 수정 및 삭제를 해도 참조 테이블이 자동으로 적용되는 것을 볼 수 있다.

### 5-2-4. 기타 제약조건

#### 고유 키 제약조건

고유 키 제약조건은 '**중복되지 않는 유일한 값**'을 입력해야 하는 조건이다. 기본 키 제약조건과 다른 점은 **NULL 값을 허용**한다는 것이다. 또한, 기본 키와 달리 **여러 개를 설정**할 수 있다.

#### 체크 제약조건

체크 제약조건은 입력되는 데이터를 점검하는 기능을 한다. 열의 정의 뒤에 CHECK(조건)을 추가해주면 된다.

```sql
...
height  TINYINT UNSIGNED NULL CHECK (height >= 100)
...
```
혹은 테이블을 만든 후에 ALTER TABLE 문으로 제약조건을 추가해도 된다.
```sql
ALTER TABLE member
	ADD CONSTRAINT
    CHECK (phone1 IN ('02', '031', '032', '054', '055', '061'));
```

#### 기본값 정의

기본값 정의는 값을 입력하지 않았을 때 자동으로 입력될 값을 미리 지정해 놓는 방법이다. 열을 정의할 때 옆에 `DEFAULT 데이터`와 같이 작성한다. ALTER TABLE 문에 작성해도 동일한 효과를 갖는다.

```sql
ALTER TABLE member
	ALTER COLUMN phone1 SET DEFAULT '02';
```

열에 지정할 떄는 **`ALTER COLUMN`** 을 사용하여 DEFALUT를 작성하도록 한다.

기본값이 설정된 열에 기본값을 입력하려면 **default**라고 써주고, 원하는 값을 입력하려면 해당 값을 써주면 된다.

#### NULL 값 허용

널값을 허용하려면 생략하거나 NULL을 사용하고, 허용하지 않으려면 NOT NULL을 사용한다.