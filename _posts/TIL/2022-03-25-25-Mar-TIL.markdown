---
layout: post
title: "25 Mar TIL: Node.js commander 패키지, 배포환경"
excerpt: "commander package, production"
date: 2022-03-25 23:33:00 +0900
categories:
  - Study
tags:
  - TIL
---

# commander의 program 객체 메서드

* version: 프로그램의 버전을 설정. 첫 번째 인수로 버전을 넣어주고, 두 번째 인수로 버전을 보여줄 옵션을 넣는다. 여러 개인 경우 쉼표(,)로 구분한다.

* usage: 이 메서드를 사용하면 명령어의 사용법을 설정할 수 있다. 도움 옵션(-h or --help)를 붙였을 때 설명서에 표시된다.

* name: 명령어의 이름을 넣는다.

* command: 명령어를 설정하는 메서드. <>는 필수라는 의미로 값을 넣지 않으면 에러가 발생한다. *는 와일드카드 명령어로, 나머지 모든 명령어를 의미한다.

* description: 명령어에 대한 설명을 설정하는 메서드.

* alias: 명령어의 별칭을 설정. template이 명령어라면, tmpl로 별칭을 설정하여 실행할 수 있다.

* option: 명령어에 대한 부가적인 옵션을 설정한다. 첫 번째 인수가 옵션 명령어고, 두 번째 인수가 옵션에 대한 설명이다. 마지막 인수는 옵션 기본값이다.

* requiredOption: option과 같은 역할을 하지만 필수로 입력해야 하는 옵션을 지정할 때 사용.

* action: 명령어에 대한 실제 동작을 정의하는 메서드. <> 같은 필수 요소나 옵션들을 매개변수로 가져올 수 있다.

* help: 설명서를 보여주는 옵션.

* parse: program 객체의 마지막에 붙이는 메서드. process.argv를 인수로 받아서 명령어와 옵션을 파싱한다.

콘솔에서 실행할 때 옵션으로 설정했던 값들은 순서를 바꿔서 입력해도 된다.

# inquirer

commander를 사용하더라도, 사용자가 코맨트들을 알고 있어야 하는 점이 문제이다. 이를 해결하기 위해 사용자와 상호작용하는 CLI가 필요하다. 이때 사용하는 패키지가 inquirer 패키지이다. inquirer의 객체들은 다음과 같다.

* type: 질문의 종류. input, checkbox, list, password, confirm 등이 있다.

* name: 질문의 이름. 나중에 답변 객체가 속성명으로 질문의 이름을, 속성값으로 질문의 답을 가지게 된다.

* message: 사용자에게 표시되는 문자열이다. 여기에 질문을 작성한다.

* choices: type이 checkbox, list 등인 경우 선택지를 넣는 곳. 배열로 넣으면 된다.

* default: 답을 적지 않았을 경우 적용되는 기본값

# 배포환경 구축

## morgan, express-session

morgan과 express-session은 개발용으로 되어있었으므로 이 미들웨어들을 배포용으로 바꾼다. 배포 환경일 때 주로 morgan은 combined 모드를 사용한다. 더 많은 사용자 정보를 로그로 남기므로 추후 버그를 해결할 때 더 유용하게 사용할 수 있다. 개발 환경인지 배포 환경인지에 따라 env 값이 변해야 하는데 .env 파일은 정적이므로 동적 파일로 바꾸어야 한다.

## sequelize

시퀄라이즈의 가장 큰 문제점인 비밀번호 하드 코딩을 대체하기 위해 js 파일을 설정 파일로 사용한다. 이렇게 하면, 변수를 사용하여 비밀번호를 입력할 수 있다. 나머지 정보도 숨길 수 있고 username 속성이나 host 속성은 각각 아이디와 DB 서버 주소 역할을 하므로 숨기는 것이 좋다.

쿼리를 수행할 때마다 콘솔에 SQL문이 노출되므로 배포 환경에서는 어떤 쿼리가 수행되는지 숨기는 것이 좋다.

## cross-env

cross-env 패키지를 사용하면 동적으로 process.env(환경 변수)를 변경할 수 있다. npm start를 배포 환경에서 사용하도록 `NODE_ENV=production PORT=80`을 앞에 붙여준다. 이 방법은 스크립트를 실행할 때 process.env를 동적으로 설정하는 방법이다. process.env.NODE_ENV가 production이 되고 process.env.PORT가 80이 된다. 다만 윈도우에서는 process.env를 이렇게 설정할 수 없으므로, cross-env를 설치하여 `cross-env NODE_ENV=production PORT=80 node server`로 설정한다.

## sanitize-html, csurf

sanitize-html과 csurf 패키지는 각각 XSS(Cross Site Scripting), CSRF(Cross Site Request Forgery) 공격을 막기 위한 패키지이다.

XSS는 악의적인 사용자가 사이트에 스크립트를 삽입하는 공격이다. 악성 사용자가 게시글이나 댓글 등을 업로드할 때 자바스크립트가 포함된 태그를 올리면, 나중에 다른 사용자가 그 게시글이나 댓글을 볼 때 그 스크립트가 실행되어서 예기치 못한 동작을 하게 된다.

따라서 서버에서는 사용자가 게시글을 업로드할 때 스크립트가 포함되어 있는지 검사해서, 존재한다면 제거해야 한다. 다만, 공격성 스크립트 유형이 많으므로 라이브러리의 도움을 받는 것이 좋다.

CRSF는 사용자가 의도치 않게 공격자가 의도한 행동을 하게 만드는 공격이다. 이 공격을 막으려면 내가 한 행동이 내가 한 것이 맞다는 점을 인증해야 한다. 이때 CSRF 토큰이 사용되고, csurf 패키지는 이 토큰을 쉽게 발급하거나 검증할 수 있도록 돕는다.

```js
const csrf = require('csurf');
const csrfProtection = csrf({ cookie: true });

app.get('/form', csrfProtection, (req, res) => {
    res.render('csrf', { csrfToken: req.csrfToken() });
});

app.post('/form', csrfProtection, (req, res) => {
    res.send('ok');
});
```

익스프레스의 미들웨어 형식으로 동작하며 CRSF 토큰을 같이 제공한다. 토큰은 req.csrfToken()으로 가져올 수 있다. 프런트엔드에 렌더링된 CSRF 토큰을 나중에 form을 제출할 때 데이터와 함께 제출하면 된다.

## pm2

pm2는 원활한 서버 운영을 위한 패키지이다. 가장 큰 기능은 서버가 에러로 인해 꺼졌을 때 서버를 다시 켜주는 것이다.

또 하나의 중요한 가능은 바로 **멀티 프로세싱**이다. 멀티 스레딩은 아니지만 멀티 프로세싱을 지원하여 노드 프로세스 개수를 한 개 이상으로 늘릴 수 있다. 기본적으로 CPU 코어를 하나만 사용하는데, pm2를 사용해서 프로세스를 여러 개 만들면 다른 코어들까지 사용할 수 있다. 클라이언트로부터 요청이 올 때 알아서 요청을 여러 노드 프로세스에 고르게 분배한다. 하나의 프로세스가 받는 부하가 적어지므로 서비스를 더 원활하게 운영할 수 있다.

단점은 멀티 스레딩이 아니므로 서버의 메모리 같은 자원을 공유하지는 못한다. 지금까지 세션을 메모리에 저장했는데, 메모리를 공유하지 못해서 프로세스 간에 세션이 공유되지 않게 된다. 로그인 후 새로고침을 반복할 때 세션 메모리가 있는 프로세스로 요청이 가면 로그인된 상태가 되고, 세션 메모리가 없는 프로세스로 요청이 가면 로그인되지 않은 상태가 되는 것이다.

이 문제를 극복하기 위해서는 세션을 공유할 수 있게 해주는 무언가가 필요한데, 이를 위해 멤캐시드나 레디스 같은 서비스를 사용한다.

pm2를 실행하면 node나 nodemon 명령어와는 다르게 노드 프로세스가 실행된 후에 콘솔에 다른 명령어를 입력할 수 있다. pm2가 노드 프로세스를 백그라운드로 돌리므로 가능하다.