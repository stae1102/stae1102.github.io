---
layout: post
title: "백준: 1799 비숍"
excerpt: "Python, backtracking"
date: 2022-03-18 09:01:00 +0900
categories:
  - Baekjoon
tags:
  - backtracking
---

- [문제](#문제)
- [입력](#입력)
- [출력](#출력)
- [문제 풀이](#문제-풀이)
  - [A. 아이디어](#a-아이디어)
  - [B. 코드 분석](#b-코드-분석)
    - [전체 코드](#전체-코드)
    - [B-1. 준비](#b-1-준비)
      - [맵 체크 대각선](#맵-체크-대각선)
      - [비숍 체크 대각선](#비숍-체크-대각선)
    - [B-2. 풀이](#b-2-풀이)
    - [B-3. 출력](#b-3-출력)
- [총평](#총평)

# 문제

서양 장기인 체스에는 대각선 방향으로 움직일 수 있는 비숍(bishop)이 있다. < 그림 1 >과 같은 정사각형 체스판 위에 B라고 표시된 곳에 비숍이 있을 때 비숍은 대각선 방향으로 움직여 O로 표시된 칸에 있는 다른 말을 잡을 수 있다.



<p align="center">
<img src="https://upload.acmicpc.net/c3f4ac55-3e37-4bed-a381-7d407b2f9b4f/-/preview/" width="50%" />
<p align="center">< 그림 1 ></p>
</p>

그런데 체스판 위에는 비숍이 놓일 수 없는 곳이 있다. < 그림 2 >에서 체스판에 색칠된 부분은 비숍이 놓일 수 없다고 하자. 이와 같은 체스판에 서로가 서로를 잡을 수 없도록 하면서 비숍을 놓는다면 < 그림 3 >과 같이 최대 7개의 비숍을 놓을 수 있다.  색칠된 부분에는 비숍이 놓일 수 없지만 지나갈 수는 있다.

<p align="center">
<img src="https://upload.acmicpc.net/3d44f5a2-bd28-41bd-9959-0f8f8bfbff3f/-/preview/" width="50%" />
<p align="center">< 그림 2 ></p>
</p>

<p align="center">
<img src="https://upload.acmicpc.net/49405f78-09c9-4220-8687-ec3269dd6c1b/-/preview/" width="50%" />
<p align="center">< 그림 3 ></p>
</p>

정사각형 체스판의 한 변에 놓인 칸의 개수를 체스판의 크기라고 한다. 체스판의 크기와 체스판 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 주어질 때, 서로가 서로를 잡을 수 없는 위치에 놓을 수 있는 비숍의 최대 개수를 구하는 프로그램을 작성하시오.

# 입력

첫째 줄에 체스판의 크기가 주어진다. 체스판의 크기는 10이하의 자연수이다. 둘째 줄부터 아래의 예와 같이 체스판의 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 체스판 한 줄 단위로 한 줄씩 주어진다. 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0이 빈칸을 사이에 두고 주어진다.

# 출력

첫째 줄에 주어진 체스판 위에 놓을 수 있는 비숍의 최대 개수를 출력한다.

# 문제 풀이

## A. 아이디어

https://www.acmicpc.net/problem/9663

N-Queen을 참고하며 대각선을 받는 테이블을 생성한다. 이후 대각선을 순회하며 가능한 것들을 while문을 통해 대각선들을 탐색하며 찾아낸다.

또한, 체스 판에 검은 색과 흰 색이 공존하는데, **검은색에 있는 비숍은 절대로 흰색에 있는 비숍을 잡을 수 없으며, 흰색에 있는 비숍도 검은색에 있는 비숍을 절대 잡을 수 없다.**

즉, 홀수 열에 있는 비숍은 홀수 열만 체크하면 되고, 짝수 열에 있는 비숍은 짝수 열만 체크하면 된다.

대각선을 돌아다니며 주어진 체스 맵과 비교하고, 대각선 리스트에서 저장된 값이 없다면 대각선 리스트에 값을 추가하고 재귀로 들어간다.

## B. 코드 분석

### 전체 코드

```py
import sys
input = sys.stdin.readline

N = int(input())

chess = [list(map(int, input().split())) for _ in range(N)]
d = [0] * (2 * N - 1)

def fn(n):
    if n >= 2 * N - 1:
        return 0
    
    ans = -1
    x, y = (0, n) if n < N else (n - (N - 1), N - 1)
    while y >= 0 and x < N:
        if (chess[y][x] == 1 and d[x - y + N - 1] == 0):
            d[x - y + N - 1] = 1
            temp = fn(n + 2) + 1
            ans = max(ans, temp)
            d[x - y + N - 1] = 0

        x += 1
        y -= 1
    
    if ans < 0:
        ans = max(ans, fn(n + 2))

    return ans

fn_0 = fn(0)
fn_1 = fn(1)

print(fn_0 + fn_1)
```

### B-1. 준비

```py
import sys
input = sys.stdin.readline

N = int(input())

chess = [list(map(int, input().split())) for _ in range(N)]
d = [0] * (2 * N - 1)
```

체스판 맵 리스트를 만든다.

d 리스트는 좌상에서 우하로 내려가는 대각선(오른쪽 아래 대각선)을 체크하기 위해 만들었다.

#### 맵 체크 대각선

![1799 비숍](https://user-images.githubusercontent.com/83271772/158915691-9f1c65ee-a353-4286-abce-ee546a5ef753.png)

<p align="center"><그림 4></p>

위 그림은 주어진 chess 맵에서 비숍이 설 수 있는 곳을 체크할 때 사용할 대각선이다. 

즉 흰색의 비숍을 체크한다고 가정한다면 흰색 대각선에 해당하는 곳을 체크하며 백트래킹하는 것이다.

예를 들어 6번 대각선을 탐색한다고 할 때, 좌하단부터 우상단까지 체크하는 것이다.

#### 비숍 체크 대각선

<img src="https://user-images.githubusercontent.com/83271772/158915691-9f1c65ee-a353-4286-abce-ee546a5ef753.png" style="transform:rotate(270deg);">

<p align="center"><그림 5></p>


사실 이 그림4와 그림5는 똑같은 기능을 하는 대각선이다. 그림 5에서 하나라도 배치한 비숍이 있다면 그냥 넘어가는 것이다.

이 그림 5는 d = [0] * (2 * N - 1)의 역할을 한다.

len(d)가 2 * N - 1 인 이유는 대각선이 총 2 * N - 1개 있기 때문이다. 그림에서 맨 왼쪽 위부터 오른쪽으로 'ㄱ' 방향으로 세보면 총 2 * N - 1개가 되는 것을 알 수 있다. 2 * N을 하면 1개의 블록이 겹치기 때문에 하나를 뺀다고 생각해도 된다.

### B-2. 풀이

```py
def fn(n):
    if n >= 2 * N - 1:
        return 0
    
    ans = -1
    x, y = (0, n) if n < N else (n - (N - 1), N - 1)
    while y >= 0 and x < N:
        if (chess[y][x] == 1 and d[x - y + N - 1] == 0):
            d[x - y + N - 1] = 1
            temp = fn(n + 2) + 1
            ans = max(ans, temp)
            d[x - y + N - 1] = 0

        x += 1
        y -= 1
    
    if ans < 0:
        ans = max(ans, fn(n + 2))

    return ans
```
fn(n)에서의 인수 n은 대각선 위치이다. 

---

```py
if n >= 2 * N - 1:
    return 0
```
대각선은 0 ~ (2 * N - 1) - 1 의 범위를 갖기 때문에 그 이상의 것들은 불가능하기 때문에 0을 리턴한다.

---

```py
    ans = -1
    x, y = (0, n) if n < N else (n - (N - 1), N - 1)
```
매번 ans 변수를 max로 저장해야 하기 때문에 while 문을 실행하기 전에 ans 변수를 먼저 선언한다. 먼저 선언하지 않으면 `ans = max(ans, temp)`에서 선언하기 전에 사용했다고 오류가 발생한다.

`x, y = (0, n) if n < N else (n - (N - 1), N - 1)`부분은 좌하단부터 체크하기 위해 x, y 위치를 초기화 해주는 부분이다. 체스맵은 chess[y][x] 이렇게 읽기 위해서 x와 y를 반대로 지정했다(2차함수 그래프는 가로가 x, 세로가 y이기 때문이다).

* **n < N일 때**  

대각선을 체크할 때 N - 1을 지나기 전에는 좌하단 좌표를 보면 `x = 0, y = n`이다. 예를 들어 <그림4>에서 6번째 대각선의 가장 아래쪽 좌표는 `x = 0, y = 6`이다.

* **n >= N일 때**

대각선이 최대 그림4를 보면 N - 1 대각선을 지나가기 시작하면 fn(n)의 n이 아무리 커져도 x는 (n - (N - 1))로 고정되고, y는 n으로 고정된다. 예를 들어 <그림4>에서 8번째 대각선의 가장 아래쪽 좌표는 `x = 8 - (8 - 1) = 7, y = 7`인 것을 확인할 수 있다.

---

```py
while y >= 0 and x < N:
    if (chess[y][x] == 1 and d[x - y + N - 1] == 0):
        d[x - y + N - 1] = 1
        temp = fn(n + 2) + 1
        ans = max(ans, temp)
        d[x - y + N - 1] = 0

    x += 1
    y -= 1
```

그렇게 x와 y좌표를 초기화 한 다음 while문을 돌기 시작한다.

좌표는 우상단으로 이동하기 때문에 y는 1씩 작아지고, x는 1씩 커진다. 그래서 while문의 충족 범위는 y >= 0으로 0 이상의 정수이고, x < N으로 N을 벗어나지 않는다.

이때 내가 순회하는 대각선의 좌표를 체크할 때 그 곳이 **체스맵에 주어진 가능한 영역**이라고 했을 때, 그리고 동시에 **<그림5>에서 그 대각선에 놓인 비숍이 없을 때**(좌상우하 대각선에 비숍이 없을 때), 그 대각선에 비숍이 놓였다는 의미로 `d[x - y + N - 1] = 1`로 설정한다.

이렇게 조건을 충족하면 그곳에 비숍을 놓을 수 있으므로 1을 더하고, 그 다음 조건인 f(n + 2)를 순회한다.

---

```py
if ans < 0:
    ans = max(ans, fn(n + 2))

return ans
```

만약 충족하는 것이 하나도 없으면 fn(n + 2)로 이동한다.

최종적으로 max 값을 가지는 ans를 리턴한다.

### B-3. 출력

```py
fn_0 = fn(0)
fn_1 = fn(1)

print(fn_0 + fn_1)
```
체스판의 검은색에서부터 순회하는 경우와 흰색에서부터 순회하는 경우를 모두 체크하여 둘을 더해준다.

# 총평

백트래킹의 조건 설정은 할 만한데, 그 때의 카운트나 최댓값이나 순서 등 백트래킹하면서 필요한 변수를 뽑아내는 게 아직은 어렵다. 아직 return을 어떻게 해야 올바른 것인지도 헷갈린다. 더 많은 문제를 풀면서 고민해야겠다.

이 문제는 한국정보올림피아드 초등부 문제였다. 초등부 학생들이 벌써부터 이런 문제를 푼다니 대한민국의 미래가 밝다. 이게 진짜 학생들이 원해서 공부하며 올림피아드에 참가했을지 아니면 부모님의 강요로 공부해서 올림피아드에 참가했을지 생각해보면 아무래도 후자가 좀 더 많을 것 같아서 씁쓸하다.

![1799](https://user-images.githubusercontent.com/83271772/158919493-89da8c02-5ade-45e2-bd9b-a2149d953827.PNG)